<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!--<![endif]-->

<head>
  <title>cmu15445 project#2 - Extendable Hash Index | Comethru</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Comethru">
    <meta name="author" content="DaiWei Jia">
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="Comethru" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
    
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    

    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->

  
  
  

  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            <li>
                <a class="sb-toggle-submenu">Works<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                        <li><a href="/" target="_BLANK" class="animsition-link">AAA</a></li>
                    
                        <li><a href="/atom.xml" target="_BLANK" class="animsition-link">BBB</a></li>
                    
                </ul>
            </li>
            
            
            
            <li>
                <a class="sb-toggle-submenu">Links<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                    <li><a target="_blank" rel="noopener" href="http://go.kieran.top/" class="animsition-link">Kieran</a></li>
                    
                    <li><a target="_blank" rel="noopener" href="http://domain.com/" class="animsition-link">Name</a></li>
                    
                </ul>
            </li>
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo.png" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">Comethru</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a></li>
                            
                            
                            <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a></li>
                            
                            
                            <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a></li>
                            
                            
                            <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a></li>
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->


      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2022-09-09T08:18:46.345Z" itemprop="datePublished">
          2022-09-09
      </time>
    
</span>
                <h1>cmu15445 project#2 - Extendable Hash Index</h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<h2 id="Project-2-Extend-able-Hash-Index"><a href="#Project-2-Extend-able-Hash-Index" class="headerlink" title="Project #2: Extend-able Hash Index"></a>Project #2: Extend-able Hash Index</h2><p>这部分实验要求为DBMS实现一个基于磁盘的可扩展哈希表，用于快速检索数据（个人理解是支持点查询）</p>
<p>实验地址：<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/fall2021/project2/">https://15445.courses.cs.cmu.edu/fall2021/project2/</a></p>
<h3 id="Task-1-Page-Layouts"><a href="#Task-1-Page-Layouts" class="headerlink" title="Task #1: Page Layouts"></a>Task #1: Page Layouts</h3><p>依赖于Project1的实现，哈希表需要通过DBMS的BufferPoolManager访问，即所有数据信息都必须保存在磁盘页面中，访问哈希表时通过BufferPoolManager从磁盘读取加载页面，完成后将更改写回磁盘。Task1需要实现两个Page类来存储哈希表的数据：</p>
<p><strong>Hash Table Directory Page：</strong></p>
<p>directory page保存哈希表的所有元数据，包含以下字段：</p>
<ul>
<li><code>page_id_</code>：目录页（即当前页面）的page id</li>
<li><code>lsn_</code>：日志序列号（在Project4中使用）</li>
<li><code>global_depth_</code>：全局深度，表示目录大小（<code>1&lt;&lt;global_depth_</code>），还用于将哈希值分流到不同bucket</li>
<li><code>local_depths_</code>：存放每个bucket的局部深度，通过bucket id索引</li>
<li><code>bucket_page_ids_</code>：存放每个bucket对应的page id，通过bucket id索引</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">page_id_t</span> page_id_;</span><br><span class="line"><span class="keyword">lsn_t</span> lsn_;</span><br><span class="line"><span class="keyword">uint32_t</span> global_depth_&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">uint8_t</span> local_depths_[DIRECTORY_ARRAY_SIZE];</span><br><span class="line"><span class="keyword">page_id_t</span> bucket_page_ids_[DIRECTORY_ARRAY_SIZE];</span><br></pre></td></tr></table></figure>

<p><code>HashTableDirectoryPage</code>类包含以下成员函数（只列举重要的）：</p>
<p><code>global_depth_</code>相关成员函数，增加和减少<code>global_depth_</code>时需要注意不能越界：<code>global_depth_</code>是<code>uint32_t</code>类型，因此等于0时如果再减1会变成<code>uint32_t</code>能表示的最大值；配置文件规定<code>DIRECTORY_ARRAY_SIZE</code>为512，因此<code>global_depth_</code>的最大值为9</p>
<p><code>GetGlobalDepthMask</code>函数返回一个基于当前<code>global_depth_</code>的掩码，通过与哈希值取交集将key映射到对应的bucket（可以简单理解为低<code>global_depth_</code>位置1，其它位置0，例如当前<code>global_depth_</code>为3则返回<code>0x00000007</code>）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">HashTableDirectoryPage::GetGlobalDepth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> global_depth_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">HashTableDirectoryPage::GetGlobalDepthMask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; global_depth_) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HashTableDirectoryPage::IncrGlobalDepth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(global_depth_ &lt; MAX_GLOBAL_DEPTH);</span><br><span class="line">  global_depth_++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HashTableDirectoryPage::DecrGlobalDepth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(global_depth_ &gt; <span class="number">0</span>);</span><br><span class="line">  global_depth_--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>local_depth</code>相关成员函数，增加减少<code>local_depth</code>时同样需要注意越界问题，并且<code>local_depth</code>必须小于等于<code>global_depth_</code></p>
<p><code>GetLocalDepthMask</code>函数返回对应bucket的<code>local_depth</code>掩码（在rehash的时候会用到）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">HashTableDirectoryPage::GetLocalDepth</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bucket_idx &gt;= DIRECTORY_ARRAY_SIZE) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> local_depths_[bucket_idx];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HashTableDirectoryPage::SetLocalDepth</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx, <span class="keyword">uint8_t</span> local_depth)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bucket_idx &gt;= DIRECTORY_ARRAY_SIZE) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>(local_depth &lt;= global_depth_);</span><br><span class="line">  local_depths_[bucket_idx] = local_depth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HashTableDirectoryPage::IncrLocalDepth</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bucket_idx &gt;= DIRECTORY_ARRAY_SIZE) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>(local_depths_[bucket_idx] &lt; global_depth_);</span><br><span class="line">  local_depths_[bucket_idx]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HashTableDirectoryPage::DecrLocalDepth</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bucket_idx &gt;= DIRECTORY_ARRAY_SIZE) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>(local_depths_[bucket_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  local_depths_[bucket_idx]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">HashTableDirectoryPage::GetLocalDepthMask</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; local_depths_[bucket_idx]) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CanShrink</code>函数返回当前目录是否能够收缩，当且仅当目录中所有bucket的<code>local_depth</code>都小于<code>global_depth_</code>时才可以收缩</p>
<p><code>GetLocalHighBit</code>函数返回bucket对应<code>local_depth</code>的高位，例如<code>local_depth</code>为3（011）返回4（100）</p>
<p><code>GetSplitImageIndex</code>函数返回指定bucket对应的split image bucket的索引（通过对<code>local_depth</code>位取反），在split和merge时会用到</p>
<p><code>GetLocalHighBit</code>和<code>GetSplitImageIndex</code>函数需要结合起来理解，设定当前<code>bucket_idx</code> = 3(011)，<code>local_depth</code> = 2，bucket已满需要分裂：</p>
<p><code>local_depth</code> 加1变成3，<code>GetLocalHighBit</code>函数返回<code>1&lt;&lt;2 = 4(100)</code>，<code>011 ^ 100 = 111 = 7</code>，7即为split image bucket的索引（原本<code>local_depth</code>为2，只需要通过hash值的最后两位来区分，bucket满了分裂成两个bucket后，自然需要新加一位即通过最后三位来将所有哈希值最后两位相同的键值对rehash到新旧两个bucket中，即索引为111和011的两个bucket）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HashTableDirectoryPage::CanShrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> bucket_idx = <span class="number">0</span>; bucket_idx &lt; <span class="built_in">Size</span>(); ++bucket_idx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetLocalDepth</span>(bucket_idx) &gt;= global_depth_) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(<span class="built_in">GetLocalDepth</span>(bucket_idx) == global_depth_);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">HashTableDirectoryPage::GetLocalHighBit</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; (local_depths_[bucket_idx] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">HashTableDirectoryPage::GetSplitImageIndex</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bucket_idx ^ <span class="built_in">GetLocalHighBit</span>(bucket_idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Hash Table Bucket Page：</strong></p>
<p>bucket page存放bucket元数据和哈希表中映射到该bucket的键值对，包含以下字段：</p>
<ul>
<li><code>occupied_</code>：记录bucket中每个位置是否被占用（只要使用过就为1）</li>
<li><code>readable_</code>：记录bucket中每个位置是否存放了键值对</li>
<li><code>array_</code>：bucket中存放的键值对数组</li>
</ul>
<p><code>BUCKET_ARRAY_SIZE</code>表示桶中最多可以存放的键值对个数，由存放的键值对类型决定（不同哈希表可能存放不同类型的键值对），存放一个键值对需要<code>sizeof(MappingType)</code><strong>字节</strong>的存储空间，同时分别需要<code>occupied_</code>和<code>readable_</code>数组的一个<strong>比特</strong>来记录当前状态，因此每个键值对总共需要<code>sizeof(MappingType) + 1/4</code><strong>字节</strong>的存储空间，因此bucket中能够存放的键值对个数最大为：<code>BUCKET_ARRAY_SIZE = PAGE_SIZE / (sizeof(MappingType) + 1/4)</code>，分子分母同时乘4结果不变</p>
<p><code>occupied_</code>和<code>readable_</code>数组长度定义为<code>(BUCKET_ARRAY_SIZE - 1) / 8 + 1</code>即<code>BUCKET_ARRAY_SIZE / 8</code>的上界（<code>BUCKET_ARRAY_SIZE</code>个键值对，每个键值对需要<code>1/8</code>字节）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  For more on BUCKET_ARRAY_SIZE see storage/page/hash_table_page_defs.h</span></span><br><span class="line"><span class="keyword">char</span> occupied_[(BUCKET_ARRAY_SIZE - <span class="number">1</span>) / <span class="number">8</span> + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 0 if tombstone/brand new (never occupied), 1 otherwise.</span></span><br><span class="line"><span class="keyword">char</span> readable_[(BUCKET_ARRAY_SIZE - <span class="number">1</span>) / <span class="number">8</span> + <span class="number">1</span>];</span><br><span class="line">MappingType array_[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p><code>HashTableBucketPage</code>类主要包含以下成员函数：</p>
<p><code>IsOccupied</code>和<code>IsReadable</code>函数分别查询给定<code>bucket_idx</code>位置的状态信息，<code>BIT_IDX</code>宏返回状态信息存放在数组的哪个元素中，<code>BIT_OFFSET</code>宏返回状态信息位于该元素的第几位；<code>IsReadable</code>返回true表示对应位置存放了键值对，<code>IsOccupied</code>返回true表示对应位置被占用过（当前不一定被占用），由于插入时是从前向后查询空位，因此<code>IsOccupied</code>返回false表示遍历可以终止了</p>
<p><code>NumReadable</code>函数返回bucket中存放的键值对个数，<code>IsFull</code>和<code>IsEmpty</code>函数分别返回bucket是否已满/为空</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT_IDX(idx) ((idx) / 8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT_OFFSET(idx) ((idx) % 8)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HASH_TABLE_BUCKET_TYPE::IsOccupied</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(bucket_idx &lt; BUCKET_ARRAY_SIZE);</span><br><span class="line">  <span class="keyword">return</span> occupied_[<span class="built_in">BIT_IDX</span>(bucket_idx)] &amp; (<span class="number">1</span> &lt;&lt; <span class="built_in">BIT_OFFSET</span>(bucket_idx));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HASH_TABLE_BUCKET_TYPE::IsReadable</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(bucket_idx &lt; BUCKET_ARRAY_SIZE);</span><br><span class="line">  <span class="keyword">return</span> readable_[<span class="built_in">BIT_IDX</span>(bucket_idx)] &amp; (<span class="number">1</span> &lt;&lt; <span class="built_in">BIT_OFFSET</span>(bucket_idx));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">HASH_TABLE_BUCKET_TYPE::NumReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> readable = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> bucket_idx = <span class="number">0</span>; bucket_idx &lt; BUCKET_ARRAY_SIZE; bucket_idx++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsOccupied</span>(bucket_idx)) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsReadable</span>(bucket_idx)) &#123;</span><br><span class="line">      readable++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> readable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HASH_TABLE_BUCKET_TYPE::IsFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NumReadable</span>() == BUCKET_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HASH_TABLE_BUCKET_TYPE::IsEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NumReadable</span>() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>GetValue</code>函数扫描bucket获取指定key对应的value值，添加到给定的vector中（规定一个key可以对应多个value）</p>
<p><code>Insert</code>函数先扫描bucket查看有没有空位（<code>IsReadable</code>返回false）以及要插入的键值对是否已经存在（key相同且value相同），没有空位或键值对已经存在则直接返回false，否则设置<code>occupied_</code>和<code>readable_</code>数组对应位置为1，并将键值对存入<code>array_</code>数组</p>
<p><code>Remove</code>函数先扫描bucket查看要移除的键值对是否存在，不存在直接返回false，存在则调用<code>RemoveAt</code>函数设置<code>occupied_</code>和<code>readable_</code>数组对应位置为0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HASH_TABLE_BUCKET_TYPE::GetValue</span><span class="params">(KeyType key, KeyComparator cmp, std::vector&lt;ValueType&gt; *result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> bucket_idx = <span class="number">0</span>; bucket_idx &lt; BUCKET_ARRAY_SIZE; bucket_idx++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsOccupied</span>(bucket_idx)) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsReadable</span>(bucket_idx)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">cmp</span>(array_[bucket_idx].first, key)) &#123;</span><br><span class="line">        result-&gt;<span class="built_in">emplace_back</span>(array_[bucket_idx].second);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> !result-&gt;<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HASH_TABLE_BUCKET_TYPE::Insert</span><span class="params">(KeyType key, ValueType value, KeyComparator cmp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> free_pos = BUCKET_ARRAY_SIZE;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> bucket_idx = <span class="number">0</span>; bucket_idx &lt; BUCKET_ARRAY_SIZE; ++bucket_idx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsReadable</span>(bucket_idx)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">cmp</span>(array_[bucket_idx].first, key) &amp;&amp; array_[bucket_idx].second == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (free_pos == BUCKET_ARRAY_SIZE) &#123;</span><br><span class="line">        free_pos = bucket_idx;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (free_pos == BUCKET_ARRAY_SIZE) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SetOccupied</span>(free_pos);</span><br><span class="line">  <span class="built_in">SetReadable</span>(free_pos);</span><br><span class="line">  array_[free_pos] = <span class="built_in">MappingType</span>(key, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HASH_TABLE_BUCKET_TYPE::Remove</span><span class="params">(KeyType key, ValueType value, KeyComparator cmp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> target_idx = BUCKET_ARRAY_SIZE;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> bucket_idx = <span class="number">0</span>; bucket_idx &lt; BUCKET_ARRAY_SIZE; ++bucket_idx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsOccupied</span>(bucket_idx)) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsReadable</span>(bucket_idx)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">cmp</span>(array_[bucket_idx].first, key) &amp;&amp; array_[bucket_idx].second == value) &#123;</span><br><span class="line">        target_idx = bucket_idx;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (target_idx == BUCKET_ARRAY_SIZE) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">RemoveAt</span>(target_idx);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HASH_TABLE_BUCKET_TYPE::RemoveAt</span><span class="params">(<span class="keyword">uint32_t</span> bucket_idx)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(bucket_idx &lt; BUCKET_ARRAY_SIZE);</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">IsOccupied</span>(bucket_idx));</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">IsReadable</span>(bucket_idx));</span><br><span class="line">  readable_[<span class="built_in">BIT_IDX</span>(bucket_idx)] ^= (<span class="number">1</span> &lt;&lt; <span class="built_in">BIT_OFFSET</span>(bucket_idx));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Task-2-Hash-Table-Implementation"><a href="#Task-2-Hash-Table-Implementation" class="headerlink" title="Task #2: Hash Table Implementation"></a>Task #2: Hash Table Implementation</h3><p>Task2要求实现一个单线程的可扩展哈希表，支持插入(Insert)、点查询(GetValue)和删除(Remove)操作。哈希表中directory page和bucket page的大小均为4KB，对应Page类中的<code>char data_[PAGE_SIZE]</code>，在获取directory page或bucket page之前需要通过BufferPoolManager的<code>FetchPage</code>方法读入对应的页面，再通过<code>reinterpre_cast</code>将页面的data属性转换为directory page或bucket page对象</p>
<p>ExtendibleHashTable类包含以下字段：</p>
<ul>
<li><code>directory_page_id_</code>：目录页page id</li>
<li><code>buffer_pool_manager_</code>：BufferPoolManager对象</li>
<li><code>comparator_</code>：用于比较两个KeyType实例，通过<code>cmp（key1, key2）</code>，key1大于key2返回1，小于返回-1，等于返回0</li>
<li><code>table_latch_</code>：哈希表读写锁</li>
<li><code>hash_fn_</code>：哈希函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// member variables</span></span><br><span class="line"><span class="keyword">page_id_t</span> directory_page_id_;</span><br><span class="line">BufferPoolManager *buffer_pool_manager_;</span><br><span class="line">KeyComparator comparator_;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Readers includes inserts and removes, writers are splits and merges</span></span><br><span class="line">ReaderWriterLatch table_latch_;</span><br><span class="line">HashFunction&lt;KeyType&gt; hash_fn_;</span><br></pre></td></tr></table></figure>

<p>ExtendibleHashTable类实现：</p>
<p>构造函数，调用BufferPoolManager的<code>NewPage</code>函数创建页面并获取页面id，通过<code>reinterpret_cast</code>将页面data属性转换为directory page对象，随后以同样的方式创建bucket page对象，并设置目录中的第一个目录项指向该bucket，最后记得调用<code>UnpinPage</code>函数解除对两个页面的引用（在<code>NewPage</code>时会Pin页面），由于修改了相关属性，因此<code>is_dirty</code>应为true</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">HASH_TABLE_TYPE::<span class="built_in">ExtendibleHashTable</span>(<span class="keyword">const</span> std::string &amp;name, BufferPoolManager *buffer_pool_manager,</span><br><span class="line">                                     <span class="keyword">const</span> KeyComparator &amp;comparator, HashFunction&lt;KeyType&gt; hash_fn)</span><br><span class="line">    : <span class="built_in">buffer_pool_manager_</span>(buffer_pool_manager), <span class="built_in">comparator_</span>(comparator), <span class="built_in">hash_fn_</span>(std::<span class="built_in">move</span>(hash_fn)) &#123;</span><br><span class="line">  <span class="comment">//  implement me!</span></span><br><span class="line">  <span class="comment">// init_lock_.lock();</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// create directory, set directory_page_id_</span></span><br><span class="line">  directory_page_id_ = INVALID_PAGE_ID;</span><br><span class="line">  <span class="keyword">auto</span> directory_page =</span><br><span class="line">      <span class="keyword">reinterpret_cast</span>&lt;HashTableDirectoryPage *&gt;(buffer_pool_manager_-&gt;<span class="built_in">NewPage</span>(&amp;directory_page_id_)-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">  directory_page-&gt;<span class="built_in">SetPageId</span>(directory_page_id_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// create first bucket, set bucket page id and local depth in directory</span></span><br><span class="line">  <span class="keyword">page_id_t</span> bucket_page_id = INVALID_PAGE_ID;</span><br><span class="line">  buffer_pool_manager_-&gt;<span class="built_in">NewPage</span>(&amp;bucket_page_id);</span><br><span class="line">  directory_page-&gt;<span class="built_in">SetBucketPageId</span>(<span class="number">0</span>, bucket_page_id);</span><br><span class="line">  directory_page-&gt;<span class="built_in">SetLocalDepth</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">true</span>));</span><br><span class="line">  <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(bucket_page_id, <span class="literal">true</span>));</span><br><span class="line">  <span class="comment">// init_lock_.unlock();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一些helper function，<code>KeyToDirectoryIndex</code>函数将key与global_depth掩码取交集，得到对应的bucket索引；<code>KeyToPageId</code>函数根据bucket索引得到对应的page id；<code>FetchDirectoryPage</code>/<code>FetchBucketPage</code>函数通过BufferPoolManager读取目录 / bucket页面返回</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">HASH_TABLE_TYPE::Hash</span><span class="params">(KeyType key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(hash_fn_.<span class="built_in">GetHash</span>(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">HASH_TABLE_TYPE::KeyToDirectoryIndex</span><span class="params">(KeyType key, HashTableDirectoryPage *dir_page)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Hash</span>(key) &amp; dir_page-&gt;<span class="built_in">GetGlobalDepthMask</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">HASH_TABLE_TYPE::KeyToPageId</span><span class="params">(KeyType key, HashTableDirectoryPage *dir_page)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dir_page-&gt;<span class="built_in">GetBucketPageId</span>(<span class="built_in">KeyToDirectoryIndex</span>(key, dir_page));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HashTableDirectoryPage *<span class="title">HASH_TABLE_TYPE::FetchDirectoryPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Page *directory_page = buffer_pool_manager_-&gt;<span class="built_in">FetchPage</span>(directory_page_id_);</span><br><span class="line">  <span class="built_in">assert</span>(directory_page != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;HashTableDirectoryPage *&gt;(directory_page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HASH_TABLE_BUCKET_TYPE *<span class="title">HASH_TABLE_TYPE::FetchBucketPage</span><span class="params">(Page *page)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;HashTableBucketPage&lt;KeyType, ValueType, KeyComparator&gt; *&gt;(page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Page *<span class="title">HASH_TABLE_TYPE::FetchPageById</span><span class="params">(<span class="keyword">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  Page *page = buffer_pool_manager_-&gt;<span class="built_in">FetchPage</span>(page_id);</span><br><span class="line">  <span class="built_in">assert</span>(page != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GetValue函数实现点查询操作，给定key，返回与之匹配的value集合：</p>
<ol>
<li>调用<code>FetchDirectoryPage</code>函数获取目录页，调用<code>FetchBucketPage</code>函数获取key对应的bucket页</li>
<li>调用bucket页的<code>GetValue</code>函数</li>
<li>解除对相关页面的引用，查询不涉及修改，因此<code>is_dirty</code>为false</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HASH_TABLE_TYPE::GetValue</span><span class="params">(Transaction *transaction, <span class="keyword">const</span> KeyType &amp;key, std::vector&lt;ValueType&gt; *result)</span> </span>&#123;</span><br><span class="line">  table_latch_.<span class="built_in">RLock</span>();</span><br><span class="line">  HashTableDirectoryPage *directory_page = <span class="built_in">FetchDirectoryPage</span>();</span><br><span class="line">  <span class="keyword">uint32_t</span> bucket_page_id = <span class="built_in">KeyToPageId</span>(key, directory_page);</span><br><span class="line">  Page *bucket_page = <span class="built_in">FetchPageById</span>(bucket_page_id);</span><br><span class="line"></span><br><span class="line">  bucket_page-&gt;<span class="built_in">RLatch</span>();</span><br><span class="line">  <span class="keyword">bool</span> is_matched = <span class="built_in">FetchBucketPage</span>(bucket_page)-&gt;<span class="built_in">GetValue</span>(key, comparator_, result);</span><br><span class="line">  bucket_page-&gt;<span class="built_in">RUnlatch</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">false</span>));</span><br><span class="line">  <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(bucket_page_id, <span class="literal">false</span>));</span><br><span class="line">  table_latch_.<span class="built_in">RUnlock</span>();</span><br><span class="line">  <span class="keyword">return</span> is_matched;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Insert</code>函数实现键值对插入操作，返回插入操作是否成功：</p>
<ol>
<li>获取目录页和对应的bucket页</li>
<li>如果bucket已满，则需要对bucket进行split操作，调用<code>SplitInsert</code>函数</li>
<li>调用bucket的<code>Insert</code>函数</li>
<li>解除对相关页面的引用，插入操作会修改bucket页，因此<code>is_dirty</code>为true</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HASH_TABLE_TYPE::Insert</span><span class="params">(Transaction *transaction, <span class="keyword">const</span> KeyType &amp;key, <span class="keyword">const</span> ValueType &amp;value)</span> </span>&#123;</span><br><span class="line">  table_latch_.<span class="built_in">RLock</span>();</span><br><span class="line">  HashTableDirectoryPage *directory_page = <span class="built_in">FetchDirectoryPage</span>();</span><br><span class="line">  <span class="keyword">uint32_t</span> bucket_page_id = <span class="built_in">KeyToPageId</span>(key, directory_page);</span><br><span class="line">  Page *bucket_page = <span class="built_in">FetchPageById</span>(bucket_page_id);</span><br><span class="line"></span><br><span class="line">  bucket_page-&gt;<span class="built_in">WLatch</span>();</span><br><span class="line">  HASH_TABLE_BUCKET_TYPE *bucket = <span class="built_in">FetchBucketPage</span>(bucket_page);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bucket-&gt;<span class="built_in">IsFull</span>()) &#123;</span><br><span class="line">    <span class="comment">// LOG_INFO(&quot;Bucket %u [page %u] is Full, Try to Split it&quot;, KeyToDirectoryIndex(key, directory_page),</span></span><br><span class="line">    <span class="comment">// bucket_page_id);</span></span><br><span class="line">    bucket_page-&gt;<span class="built_in">WUnlatch</span>();</span><br><span class="line">    <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">false</span>));</span><br><span class="line">    <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(bucket_page_id, <span class="literal">false</span>));</span><br><span class="line">    table_latch_.<span class="built_in">RUnlock</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">SplitInsert</span>(transaction, key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> is_inserted = bucket-&gt;<span class="built_in">Insert</span>(key, value, comparator_);</span><br><span class="line">  bucket_page-&gt;<span class="built_in">WUnlatch</span>();</span><br><span class="line">  <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(bucket_page_id, <span class="literal">true</span>));</span><br><span class="line">  <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">false</span>));</span><br><span class="line">  <span class="comment">// if (is_inserted) &#123;</span></span><br><span class="line">  <span class="comment">//   LOG_INFO(&quot;Insert Kvpair [%s] to Bucket %u [page %u]&quot;, KvPairToString(key, value).c_str(),</span></span><br><span class="line">  <span class="comment">//           KeyToDirectoryIndex(key, directory_page), bucket_page_id);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  table_latch_.<span class="built_in">RUnlock</span>();</span><br><span class="line">  <span class="keyword">return</span> is_inserted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SplitInsert</code>函数在插入溢出时尝试拆分bucket，并在必要的时候对目录进行扩容：</p>
<p>一些约定称谓：待拆分bucket称作<code>split_bucket</code>，其在目录中的索引称作<code>split_bucket_idx</code>，对应的页面id称作<code>split_bucket_page_id</code>；与之对应的拆分得到的bucket称为<code>split_image_bucket</code>，其在目录中的索引称作<code>split_image_idx</code>，对应的页面id称作<code>split_image_page_id</code></p>
<ol>
<li><p>获取目录页面，获取<code>split_bucket</code>页面，验证<code>split_bucket</code>是否为满（多线程下其它线程可能会删除bucket中的键值对），如果有空位，直接调用<code>split_bucket</code>的Insert函数插入键值对即可</p>
</li>
<li><p>由于拆分bucket会使得两个bucket的<code>local_depth</code>各加1，因此需要先检查<code>split_bucket</code>的<code>local_depth</code>是否大于等于最大值<code>MAX_GLOBAL_DEPTH</code>（正常情况下不会大于）</p>
</li>
<li><p>如果<code>split_bucket</code>的<code>local_depth</code>等于当前<code>global_depth</code>，说明目录需要扩容，否则拆分得到的<code>split_image_bucket</code>在目录中没有对应的索引（若<code>local_depth</code>为2的bucket索引在区间<code>[0,3]</code>，则拆分得到的bucket索引在区间<code>[4,7]</code>，而<code>global_depth</code>为2时目录中仅有4个目录项，只能索引区间<code>[0,3]</code>的bucket，因此需要对目录扩容）：</p>
<p>​    3.1 记录下当前<code>old_global_depth</code>，调用<code>IncrGlobalDepth</code>函数</p>
<p>​    3.2 从第<code>old_global_depth</code>个目录项开始（即新创建的第一个目录项开始），设置其<code>bucket_page_id</code>和<code>local_depth</code>（0xxx和1xxx目录项应指向同一个bucket且<code>local_depth</code>相同，它们之间相差<code>1&lt;&lt;old_global_depth</code>）</p>
</li>
<li><p><code>split_bucket_idx</code>对应的<code>local_depth</code>加1</p>
</li>
<li><p>调用<code>GetSplitImageIndex</code>函数获取对应的<code>split_mage_idx</code>，创建页面<code>split_image_page</code>并获取<code>split_image_page_id</code>，在目录中设置对应目录项的<code>bucket_page_id</code>和<code>local_depth</code>（<code>local_depth</code>等于<code>split_bucket_idx</code>当前<code>local_depth</code>）</p>
</li>
<li><p>更新所有与新旧bucket的<code>local_depth_mask</code>相同的目录项的<code>bucket_page_id</code>和<code>local_depth</code>，也可理解为遍历所有原本指向<code>split_bucket</code>的目录项，如果其<code>local_high_bit</code>为1，则应该指向<code>split_image_bucket</code>。split前指向<code>split_bucket</code>的目录项间距为<code>1 &lt;&lt; old_local_depth</code>，split后指向新/旧bucket的目录项间距应该翻倍，即为<code>1 &lt;&lt; cur_local_depth</code></p>
</li>
<li><p>rehash <code>split_bucket</code>中的所有键值对（应与<code>local_depth_mask</code>取交集而不是<code>global_depth_mask</code>，且只有可能rehash到<code>split_bucket</code>或<code>split_image_bucket</code>中），如果rehash到<code>split_image_bucket</code>，则从<code>split_bucket</code>中移除该键值对并插入到<code>split_image_bucket</code>中</p>
</li>
<li><p>最后调用<code>Insert</code>函数再次尝试插入键值对</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HASH_TABLE_TYPE::SplitInsert</span><span class="params">(Transaction *transaction, <span class="keyword">const</span> KeyType &amp;key, <span class="keyword">const</span> ValueType &amp;value)</span> </span>&#123;</span><br><span class="line">  table_latch_.<span class="built_in">WLock</span>();</span><br><span class="line"></span><br><span class="line">  HashTableDirectoryPage *directory_page = <span class="built_in">FetchDirectoryPage</span>();</span><br><span class="line">  <span class="keyword">uint32_t</span> split_bucket_idx = <span class="built_in">KeyToDirectoryIndex</span>(key, directory_page);</span><br><span class="line">  <span class="keyword">page_id_t</span> split_bucket_page_id = directory_page-&gt;<span class="built_in">GetBucketPageId</span>(split_bucket_idx);</span><br><span class="line">  Page *split_bucket_page = <span class="built_in">FetchPageById</span>(split_bucket_page_id);</span><br><span class="line"></span><br><span class="line">  split_bucket_page-&gt;<span class="built_in">WLatch</span>();</span><br><span class="line">  HASH_TABLE_BUCKET_TYPE *split_bucket = <span class="built_in">FetchBucketPage</span>(split_bucket_page);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.1 当前split_bucket是否Full，如果没有直接Insert</span></span><br><span class="line">  <span class="keyword">if</span> (!split_bucket-&gt;<span class="built_in">IsFull</span>()) &#123;</span><br><span class="line">    <span class="keyword">bool</span> is_inserted = split_bucket-&gt;<span class="built_in">Insert</span>(key, value, comparator_);</span><br><span class="line">    split_bucket_page-&gt;<span class="built_in">WUnlatch</span>();</span><br><span class="line">    <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(split_bucket_page_id, <span class="literal">false</span>));</span><br><span class="line">    <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">false</span>));</span><br><span class="line">    table_latch_.<span class="built_in">WUnlock</span>();</span><br><span class="line">    <span class="keyword">return</span> is_inserted;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.2 当前local_depth是否大于等于MAX_GLOBAL_DEPTH，如果是则无法split</span></span><br><span class="line">  <span class="keyword">if</span> (directory_page-&gt;<span class="built_in">GetLocalDepth</span>(split_bucket_idx) &gt;= MAX_GLOBAL_DEPTH) &#123;</span><br><span class="line">    split_bucket_page-&gt;<span class="built_in">WUnlatch</span>();</span><br><span class="line">    <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(split_bucket_page_id, <span class="literal">false</span>));</span><br><span class="line">    <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">false</span>));</span><br><span class="line">    table_latch_.<span class="built_in">WUnlock</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 如果当前local_depth等于global_depth，则需要先grow directory</span></span><br><span class="line">  <span class="keyword">if</span> (directory_page-&gt;<span class="built_in">GetLocalDepth</span>(split_bucket_idx) == directory_page-&gt;<span class="built_in">GetGlobalDepth</span>()) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> diff = <span class="number">1</span> &lt;&lt; directory_page-&gt;<span class="built_in">GetGlobalDepth</span>();</span><br><span class="line">    directory_page-&gt;<span class="built_in">IncrGlobalDepth</span>();</span><br><span class="line">    <span class="comment">// 为新创建的目录项设置bucket_page_id和local_depth</span></span><br><span class="line">    <span class="comment">// grow后split前，0xxx和1xxx目录项指向同一个bucket，他们之间相差diff</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> directory_idx = <span class="number">0</span>; directory_idx &lt; diff; ++directory_idx) &#123;</span><br><span class="line">      <span class="keyword">page_id_t</span> pair_bucket_page_id = directory_page-&gt;<span class="built_in">GetBucketPageId</span>(directory_idx);</span><br><span class="line">      <span class="keyword">uint32_t</span> pair_bucket_local_depth = directory_page-&gt;<span class="built_in">GetLocalDepth</span>(directory_idx);</span><br><span class="line"></span><br><span class="line">      directory_page-&gt;<span class="built_in">SetBucketPageId</span>(directory_idx + diff, pair_bucket_page_id);</span><br><span class="line">      directory_page-&gt;<span class="built_in">SetLocalDepth</span>(directory_idx + diff, pair_bucket_local_depth);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. split_bucket的local_depth加1</span></span><br><span class="line">  directory_page-&gt;<span class="built_in">IncrLocalDepth</span>(split_bucket_idx);</span><br><span class="line">  <span class="keyword">uint32_t</span> local_depth = directory_page-&gt;<span class="built_in">GetLocalDepth</span>(split_bucket_idx);</span><br><span class="line">  <span class="built_in">assert</span>(local_depth &lt;= directory_page-&gt;<span class="built_in">GetGlobalDepth</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 获取对应的split_image_idx, 并创建页面split_image_page</span></span><br><span class="line">  <span class="comment">//    在目录中更新对应目录项的bucket_page_id和local_depth</span></span><br><span class="line">  <span class="keyword">uint32_t</span> split_image_idx = directory_page-&gt;<span class="built_in">GetSplitImageIndex</span>(split_bucket_idx);</span><br><span class="line">  <span class="keyword">page_id_t</span> split_image_page_id = INVALID_PAGE_ID;</span><br><span class="line"></span><br><span class="line">  Page *split_image_page = buffer_pool_manager_-&gt;<span class="built_in">NewPage</span>(&amp;split_image_page_id);</span><br><span class="line">  <span class="built_in">assert</span>(split_bucket_page != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">assert</span>(split_image_page_id != INVALID_PAGE_ID);</span><br><span class="line"></span><br><span class="line">  directory_page-&gt;<span class="built_in">SetBucketPageId</span>(split_image_idx, split_image_page_id);</span><br><span class="line">  directory_page-&gt;<span class="built_in">SetLocalDepth</span>(split_image_idx, local_depth);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 更新所有与新旧bucket local_depth_mask相同的目录项的bucket_page_id和local_depth</span></span><br><span class="line">  <span class="comment">//    也可理解为遍历所有指向旧bucket的目录项，如果其local_high_bit为1，则应该指向新bucket</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// split前指向旧bucket的目录项间距为1 &lt;&lt; old_local_depth</span></span><br><span class="line">  <span class="comment">// split后指向新/旧bucket的目录项间距应该翻倍，即为1 &lt;&lt; cur_local_depth</span></span><br><span class="line">  <span class="keyword">uint32_t</span> diff = <span class="number">1</span> &lt;&lt; local_depth;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5.1 更新所有split后指向旧bucket的目录项的local_depth(bucket_page_id不变)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> directory_idx = split_bucket_idx; directory_idx &gt;= <span class="number">0</span>; directory_idx -= diff) &#123;</span><br><span class="line">    <span class="comment">// assert(directory_page-&gt;GetBucketPageId(directory_idx) == split_bucket_page_id);</span></span><br><span class="line">    directory_page-&gt;<span class="built_in">SetLocalDepth</span>(directory_idx, local_depth);</span><br><span class="line">    <span class="keyword">if</span> (directory_idx &lt; diff) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> directory_idx = split_bucket_idx; directory_idx &lt; directory_page-&gt;<span class="built_in">Size</span>(); directory_idx += diff) &#123;</span><br><span class="line">    <span class="comment">// assert(directory_page-&gt;GetBucketPageId(directory_idx) == split_bucket_page_id);</span></span><br><span class="line">    directory_page-&gt;<span class="built_in">SetLocalDepth</span>(directory_idx, local_depth);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5.2 更新所有split后指向新bucket的目录项的local_depth和bucket_page_id</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> directory_idx = split_image_idx; directory_idx &gt;= <span class="number">0</span>; directory_idx -= diff) &#123;</span><br><span class="line">    <span class="comment">// assert(directory_page-&gt;GetBucketPageId(directory_idx) == split_bucket_page_id);</span></span><br><span class="line">    directory_page-&gt;<span class="built_in">SetBucketPageId</span>(directory_idx, split_image_page_id);</span><br><span class="line">    directory_page-&gt;<span class="built_in">SetLocalDepth</span>(directory_idx, local_depth);</span><br><span class="line">    <span class="keyword">if</span> (directory_idx &lt; diff) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> directory_idx = split_image_idx; directory_idx &lt; directory_page-&gt;<span class="built_in">Size</span>(); directory_idx += diff) &#123;</span><br><span class="line">    <span class="comment">// assert(directory_page-&gt;GetBucketPageId(directory_idx) == split_bucket_page_id);</span></span><br><span class="line">    directory_page-&gt;<span class="built_in">SetBucketPageId</span>(directory_idx, split_image_page_id);</span><br><span class="line">    directory_page-&gt;<span class="built_in">SetLocalDepth</span>(directory_idx, local_depth);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6. rehash split_bucket中的所有kvpair(只有可能rehash到split_bucket或split_image_bucket中)</span></span><br><span class="line">  split_image_page-&gt;<span class="built_in">WLatch</span>();</span><br><span class="line">  HASH_TABLE_BUCKET_TYPE *split_image_bucket = <span class="built_in">FetchBucketPage</span>(split_image_page);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> pair_idx = <span class="number">0</span>; pair_idx &lt; BUCKET_ARRAY_SIZE; ++pair_idx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!split_bucket-&gt;<span class="built_in">IsOccupied</span>(pair_idx)) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (split_bucket-&gt;<span class="built_in">IsReadable</span>(pair_idx)) &#123;</span><br><span class="line">      KeyType k = split_bucket-&gt;<span class="built_in">KeyAt</span>(pair_idx);</span><br><span class="line">      ValueType v = split_bucket-&gt;<span class="built_in">ValueAt</span>(pair_idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">uint32_t</span> rehash_bucket_idx = <span class="built_in">Hash</span>(k) &amp; directory_page-&gt;<span class="built_in">GetLocalDepthMask</span>(split_bucket_idx);</span><br><span class="line">      <span class="keyword">page_id_t</span> rehash_page_id = directory_page-&gt;<span class="built_in">GetBucketPageId</span>(rehash_bucket_idx);</span><br><span class="line">      <span class="keyword">if</span> (rehash_page_id != split_bucket_page_id) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(rehash_page_id == split_image_page_id);</span><br><span class="line">        split_bucket-&gt;<span class="built_in">RemoveAt</span>(pair_idx);</span><br><span class="line">        <span class="built_in">assert</span>(split_image_bucket-&gt;<span class="built_in">Insert</span>(k, v, comparator_));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  split_image_page-&gt;<span class="built_in">WUnlatch</span>();</span><br><span class="line">  <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(split_image_page_id, <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">  split_bucket_page-&gt;<span class="built_in">WUnlatch</span>();</span><br><span class="line">  <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(split_bucket_page_id, <span class="literal">true</span>));</span><br><span class="line">  <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">true</span>));</span><br><span class="line">  table_latch_.<span class="built_in">WUnlock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Insert</span>(transaction, key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Remove</code>函数实现键值对删除操作，返回删除操作是否成功：</p>
<ol>
<li>获取目录页，以及要删除的键值对所在的bucket页</li>
<li>调用<code>Remove</code>函数删除指定键值对</li>
<li>如果bucket为空（可能是一开始就为空，也可能是删除了bucket中最后一个键值对），调用<code>Merge</code>函数尝试合并bucket</li>
<li>Unpin相关页面的引用，由于可能修改了bucket，因此对应<code>is_dirty</code>为true</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HASH_TABLE_TYPE::Remove</span><span class="params">(Transaction *transaction, <span class="keyword">const</span> KeyType &amp;key, <span class="keyword">const</span> ValueType &amp;value)</span> </span>&#123;</span><br><span class="line">  table_latch_.<span class="built_in">RLock</span>();</span><br><span class="line">  HashTableDirectoryPage *directory_page = <span class="built_in">FetchDirectoryPage</span>();</span><br><span class="line">  <span class="keyword">uint32_t</span> bucket_page_id = <span class="built_in">KeyToPageId</span>(key, directory_page);</span><br><span class="line">  Page *bucket_page = <span class="built_in">FetchPageById</span>(bucket_page_id);</span><br><span class="line"></span><br><span class="line">  bucket_page-&gt;<span class="built_in">WLatch</span>();</span><br><span class="line">  HASH_TABLE_BUCKET_TYPE *bucket = <span class="built_in">FetchBucketPage</span>(bucket_page);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> is_removed = bucket-&gt;<span class="built_in">Remove</span>(key, value, comparator_);</span><br><span class="line">  <span class="comment">// bucket is empty or remove the last pair in bucket</span></span><br><span class="line">  <span class="keyword">if</span> (bucket-&gt;<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">    bucket_page-&gt;<span class="built_in">WUnlatch</span>();</span><br><span class="line">    <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(bucket_page_id, <span class="literal">true</span>));</span><br><span class="line">    <span class="keyword">uint32_t</span> bucket_idx = <span class="built_in">KeyToDirectoryIndex</span>(key, directory_page);</span><br><span class="line">    <span class="comment">// LOG_INFO(&quot;Bucket %u [page %u] is Empty, Try to Merge it&quot;,</span></span><br><span class="line">    <span class="comment">//   bucket_idx, bucket_page_id);</span></span><br><span class="line">    <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">false</span>));</span><br><span class="line">    table_latch_.<span class="built_in">RUnlock</span>();</span><br><span class="line">    <span class="built_in">Merge</span>(transaction, bucket_idx);</span><br><span class="line">    <span class="keyword">return</span> is_removed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// remove successfully or target pair was not found in bucket</span></span><br><span class="line">  bucket_page-&gt;<span class="built_in">WUnlatch</span>();</span><br><span class="line">  <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(bucket_page_id, <span class="literal">true</span>));</span><br><span class="line">  <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">false</span>));</span><br><span class="line">  table_latch_.<span class="built_in">RUnlock</span>();</span><br><span class="line">  <span class="keyword">return</span> is_removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Merge</code>函数在bucket为空时尝试合并bucket，并尝试收缩目录：</p>
<p>一些约定称谓：待合并bucket称作<code>merge_bucket</code>，其在目录中的索引称作<code>merge_bucket_idx</code>，对应的页面id称作<code>merge_bucket_page_id</code>；要合并到的bucket称为<code>split_image_bucket</code>，其在目录中的索引称作<code>split_image_idx</code>，对应的页面id称作<code>split_image_page_id</code></p>
<ol>
<li>获取目录页面，获取<code>merge_bucket</code>页面，判断能否合并：<ul>
<li><code>merge_bucket</code>是否为空，如果不为空则无法合并</li>
<li><code>merge_bucket</code>的local_depth是否为0，为0则无法合并（因为合并local_depth会减1）</li>
<li><code>merge_bucket</code>的<code>local_depth</code>必须等于<code>split_image_bucket</code>的<code>local_depth</code></li>
<li>如果<code>merge_bucket</code>和<code>split_image_bucket</code>对应相同的bucket则无需合并</li>
</ul>
</li>
<li>解除引用并删除merge_bucket_page，<code>split_image_idx</code>和<code>merge_bucket_idx</code>的<code>local_depth</code>减1，更新<code>merge_bucket_idx</code>目录项指向<code>split_image_bucket</code></li>
<li>遍历所有目录项,如果指针指向<code>merge_bucket</code>，则<code>local_depth</code>减1并修改指针指向<code>split_image_bucket</code>，如果指向<code>split_image_bucket</code>，则<code>local_depth</code>减1即可</li>
<li>如果<code>CanShrink</code>函数返回true，则收缩目录，调用<code>DecrGlobalDepth</code>函数</li>
<li>合并或收缩目录都可能导致bucket之间的镜像关系发生变化，因此应再次尝试能否merge，检查合并后得到的<code>split_image_bucket</code>是否为空，为空则调用再次调用<code>Merge</code>函数尝试合并<code>split_image_bucket</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HASH_TABLE_TYPE::Merge</span><span class="params">(Transaction *transaction, <span class="keyword">uint32_t</span> merge_bucket_idx)</span> </span>&#123;</span><br><span class="line">  table_latch_.<span class="built_in">WLock</span>();</span><br><span class="line">  HashTableDirectoryPage *directory_page = <span class="built_in">FetchDirectoryPage</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.1 merge_bucket的local_depth是否为0，为0则无法merge</span></span><br><span class="line">  <span class="keyword">if</span> (directory_page-&gt;<span class="built_in">GetLocalDepth</span>(merge_bucket_idx) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">false</span>));</span><br><span class="line">    table_latch_.<span class="built_in">WUnlock</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.2 merge_bucket的local_depth是否等于其对应split_image_bucket的local_depth，不等于则无法merge</span></span><br><span class="line">  <span class="keyword">uint32_t</span> split_image_idx = directory_page-&gt;<span class="built_in">GetSplitImageIndex</span>(merge_bucket_idx);</span><br><span class="line">  <span class="keyword">if</span> (directory_page-&gt;<span class="built_in">GetLocalDepth</span>(merge_bucket_idx) != directory_page-&gt;<span class="built_in">GetLocalDepth</span>(split_image_idx)) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">false</span>));</span><br><span class="line">    table_latch_.<span class="built_in">WUnlock</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.3 merge_bucket是否为空，如果不为空则无法merge</span></span><br><span class="line">  <span class="keyword">page_id_t</span> merge_bucket_page_id = directory_page-&gt;<span class="built_in">GetBucketPageId</span>(merge_bucket_idx);</span><br><span class="line">  Page *merge_bucket_page = <span class="built_in">FetchPageById</span>(merge_bucket_page_id);</span><br><span class="line"></span><br><span class="line">  merge_bucket_page-&gt;<span class="built_in">RLatch</span>();</span><br><span class="line">  HASH_TABLE_BUCKET_TYPE *merge_bucket = <span class="built_in">FetchBucketPage</span>(merge_bucket_page);</span><br><span class="line">  <span class="keyword">if</span> (!merge_bucket-&gt;<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">    merge_bucket_page-&gt;<span class="built_in">RUnlatch</span>();</span><br><span class="line">    <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(merge_bucket_page_id, <span class="literal">false</span>));</span><br><span class="line">    <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">false</span>));</span><br><span class="line">    table_latch_.<span class="built_in">WUnlock</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. unpin并删除merge_bucket_page,更新相关目录项的bucket_page_id和local_depth</span></span><br><span class="line">  merge_bucket_page-&gt;<span class="built_in">RUnlatch</span>();</span><br><span class="line">  <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(merge_bucket_page_id, <span class="literal">false</span>));</span><br><span class="line">  <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">DeletePage</span>(merge_bucket_page_id));</span><br><span class="line"></span><br><span class="line">  directory_page-&gt;<span class="built_in">DecrLocalDepth</span>(split_image_idx);</span><br><span class="line">  <span class="keyword">uint32_t</span> local_depth = directory_page-&gt;<span class="built_in">GetLocalDepth</span>(split_image_idx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">page_id_t</span> split_imgae_page_id = directory_page-&gt;<span class="built_in">GetBucketPageId</span>(split_image_idx);</span><br><span class="line">  directory_page-&gt;<span class="built_in">SetBucketPageId</span>(merge_bucket_idx, split_imgae_page_id);</span><br><span class="line">  directory_page-&gt;<span class="built_in">SetLocalDepth</span>(merge_bucket_idx, local_depth);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 遍历所有目录项,如果指针指向merge_bucket,则local_depth减1并修改指针指向split_image_bucket</span></span><br><span class="line">  <span class="comment">//    如果指向split_image_bucket,则local_depth减1即可</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> direcotry_idx = <span class="number">0</span>; direcotry_idx &lt; directory_page-&gt;<span class="built_in">Size</span>(); ++direcotry_idx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (directory_page-&gt;<span class="built_in">GetBucketPageId</span>(direcotry_idx) == merge_bucket_page_id) &#123;</span><br><span class="line">      directory_page-&gt;<span class="built_in">SetBucketPageId</span>(direcotry_idx, split_imgae_page_id);</span><br><span class="line">      directory_page-&gt;<span class="built_in">SetLocalDepth</span>(direcotry_idx, local_depth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(merge_bucket_page_id != split_imgae_page_id);</span><br><span class="line">    <span class="keyword">if</span> (directory_page-&gt;<span class="built_in">GetBucketPageId</span>(direcotry_idx) == split_imgae_page_id) &#123;</span><br><span class="line">      directory_page-&gt;<span class="built_in">SetLocalDepth</span>(direcotry_idx, local_depth);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 尝试shrink目录</span></span><br><span class="line">  <span class="keyword">while</span> (directory_page-&gt;<span class="built_in">CanShrink</span>()) &#123;</span><br><span class="line">    directory_page-&gt;<span class="built_in">DecrGlobalDepth</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 由于merge/shrink后split_image关系会发生变化, 因此应再次尝试能否merge</span></span><br><span class="line">  Page *split_image_page = <span class="built_in">FetchPageById</span>(split_imgae_page_id);</span><br><span class="line">  split_image_page-&gt;<span class="built_in">RLatch</span>();</span><br><span class="line"></span><br><span class="line">  HASH_TABLE_BUCKET_TYPE *split_image_bucket = <span class="built_in">FetchBucketPage</span>(split_image_page);</span><br><span class="line">  <span class="keyword">bool</span> is_empty = split_image_bucket-&gt;<span class="built_in">IsEmpty</span>();</span><br><span class="line"></span><br><span class="line">  split_image_page-&gt;<span class="built_in">RUnlatch</span>();</span><br><span class="line">  <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(split_imgae_page_id, <span class="literal">false</span>));</span><br><span class="line">  <span class="built_in">assert</span>(buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(directory_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">true</span>));</span><br><span class="line">  table_latch_.<span class="built_in">WUnlock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_empty) &#123;</span><br><span class="line">    <span class="built_in">Merge</span>(transaction, split_image_idx);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Task-3-Concurrency-Control"><a href="#Task-3-Concurrency-Control" class="headerlink" title="Task #3: Concurrency Control"></a>Task #3: Concurrency Control</h3><p>通过对目录页和每个bucket页添加锁来支持多线程同时读取和写入哈希表，各个函数的锁方案如下：</p>
<ul>
<li><code>GetValue</code>：由于不涉及对目录页或bucket页的修改操作，因此<code>table_latch_</code>和bucket都使用读锁即可</li>
<li>Insert：<code>table_latch_</code>使用读锁，bucket页使用写锁，调用<code>SplitInsert</code>函数时应该先释放获取的锁</li>
<li>Remove：<code>table_latch_</code>使用读锁，bucket页使用写锁，调用<code>Merge</code>函数时应该先释放获取的锁</li>
<li>SplitInsert：涉及到对目录项的修改，<code>table_latch_</code>使用写锁，<code>split_bucket</code>和<code>split_image_bucket</code>都使用写锁</li>
<li>Merge：涉及到对目录项的修改，<code>table_latch_</code>使用写锁，<code>merge_bucket</code>由于已经为空，不涉及修改，因此使用读锁即可（在删除页面前要先释放锁），<code>split_image_bucket</code>使用读锁</li>
</ul>
<p>本地测试：</p>
<img src="/2022/09/09/cmu15445-lab2/result1.png" alt="result1" style="zoom:67%;">    

<p>gradescope：39.28s（感觉还有不少优化空间，空了再优化一下:&lt;）</p>
<p><img src="/2022/09/09/cmu15445-lab2/result2.png" alt="result2"></p>
<p><img src="/2022/09/09/cmu15445-lab2/result3.png" alt="result3">    </p>

            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="m-pagination col-md-8 col-md-offset-2 col-sm-24" role="pagination">
    
    <a class="pull-left" href="/2022/09/09/cmu15445-lab1/" style="float: left;">
        ← cmu15445 project#1 - Buffer Pool
    </a>
    
    
    <a class="pull-right" href="/2022/09/09/cmu15445-lab0/">
        cmu15445 project#0 - C++ Primer →
    </a>
    
</nav>

        <div class="col-md-8 col-md-offset-2 col-sm-24"><script type="text/javascript">
  /**
   * 搜狐畅言
   */

  /*
  document.write('<div id="SOHUCS" sid="' + window.location.pathname.slice(1) + '" ></div>');

  window.onload = function () {
    (function () {
      var appid = 'cytXXXX';
      var conf = 'prod_xxxxxxxxxxxxxxxxx';
      var width = window.innerWidth || document.documentElement.clientWidth;
      var loadJs = function (d, a, id) {
        var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement;
        var b = document.createElement("script");
        b.setAttribute("type", "text/javascript");
        b.setAttribute("charset", "UTF-8");
        b.setAttribute("src", d);
        if (id) {
          b.setAttribute("id", id);
        }
        if (typeof a === "function") {
          if (window.attachEvent) {
            b.onreadystatechange = function () {
              var e = b.readyState;
              if (e === "loaded" || e === "complete") {
                b.onreadystatechange = null;
                a()
              }
            }
          } else {
            b.onload = a
          }
        }
        c.appendChild(b)
      };

      loadJs("https://changyan.sohu.com/upload/changyan.js", function () {
        window.changyan.api.config({
          appid: appid,
          conf: conf
        })
      });
    })();
  }
  */

</script>
</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By DaiWei Jia. All Rights Reserved.
                </p>
                <p>Theme By <a target="_blank" rel="noopener" href="//go.kieran.top" style="color: #767D84">Kieran</a></p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a>&nbsp;</li>
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



      
</body>
</html>
