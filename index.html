<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","version":"8.7.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="Comethru">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Comethru">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="DaiWei Jia">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Comethru</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Comethru</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">DaiWei Jia</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/13/6-824-lab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DaiWei Jia">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Comethru">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/13/6-824-lab1/" class="post-title-link" itemprop="url">6.824 lab1 MapReduce</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-11-13 12:58:09 / Modified: 13:06:05" itemprop="dateCreated datePublished" datetime="2021-11-13T12:58:09+08:00">2021-11-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Lab1-MapReduce"><a href="#Lab1-MapReduce" class="headerlink" title="Lab1 MapReduce"></a>Lab1 MapReduce</h2><h4 id="MapReduce-2004"><a href="#MapReduce-2004" class="headerlink" title="MapReduce(2004)"></a><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf">MapReduce(2004)</a></h4><h4 id="Lab1-MapReduce-1"><a href="#Lab1-MapReduce-1" class="headerlink" title="Lab1 MapReduce"></a><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/labs/lab-mr.html">Lab1 MapReduce</a></h4><h4 id="Lab1-Video"><a href="#Lab1-Video" class="headerlink" title="Lab1 Video"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1R7411t71W">Lab1 Video</a></h4><h3 id="1-实验环境准备"><a href="#1-实验环境准备" class="headerlink" title="1. 实验环境准备"></a>1. 实验环境准备</h3><font size="4">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://g.csail.mit.edu/6.824-golabs-2020 6.824lab</span><br></pre></td></tr></table></figure>
<p>lab1 提供了一个顺序（非分布式）的MapReduce实现在 <code>src/main/mrsequential.go</code>中，还提供了两个MapReduce应用：词频统计 <code>mrapps/wc.go</code> 和文本索引 <code>mrapps/index.go</code></p>
<p>可以通过以下代码运行: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/6.824</span><br><span class="line">$ cd src/main</span><br><span class="line">$ go build -race -buildmode=plugin ../mrapps/wc.go</span><br><span class="line">$ rm mr-out*</span><br><span class="line">$ go run -race mrsequential.go wc.so pg*.txt</span><br><span class="line">$ more mr-out-0</span><br><span class="line">A 509</span><br><span class="line">ABOUT 2</span><br><span class="line">ACT 8</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><img src="/.com//mapreduce.png" alt="MapReduce"></p>
<p>这是<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf">MapReduce论文</a>中给出的MapReduce流程图</p>
<ol>
<li>用户程序将输入文件划分为M份 (这里的M可调控)，随后在一组机器上启动该程序的许多副本，其中一个为Master，剩下的为map worker和reduce worker，Master将M份任务中的一份分配给空闲的map worker</li>
<li>map worker将输入数据传入map函数，map函数从输入数据中解析出key/value对输出intermediate (可能以key/value形式存在)并将其写入本地磁盘</li>
<li>通过分区函数将本地磁盘的缓存对划分为R个区域 ，并将这些区域的地址传回Master，Master将这些地址转发给reduce worker</li>
<li>reduce worker读取区域中的intermediate数据，通过排序函数按key排序后，将有相同key的value放入一个集合中，将key和value集合传入reduce函数，reduce函数返回每个key对应value集合相加的值，写入输出文件</li>
<li>汇总所有reduce task的输出文件得到最终的词频数据</li>
</ol>
<h3 id="2-任务说明"><a href="#2-任务说明" class="headerlink" title="2. 任务说明"></a>2. 任务说明</h3><p>实现一个分布式的MapReduce程序，一个Master，多个Worker并行执行task，Worker和Master通过RPC对话</p>
<p>Worker通过RPC向Master请求task，完成task后通过RPC告知Master；Master应对Worker执行task的时间进行把控，超时则将task分配给其它Worker</p>
<p>通过在<code>mr/master.go</code>,<code>mr/worker.go</code>和<code>mr/rpc.go</code>中编写代码实现MapReduce</p>
<p>通过<code>bash test-mr.sh</code>测试脚本检查代码正确性</p>
<h5 id="关于Lab的一些规定"><a href="#关于Lab的一些规定" class="headerlink" title="关于Lab的一些规定"></a>关于Lab的一些规定</h5><ol>
<li>Map阶段应将intermediate划分为<code>nReduce</code>个reduce task，其中<code>nReduce</code>由<code>main/mrmaster.go</code>中<code>MakeMaster()</code>的参数指定</li>
<li>应将第x个reduce task的输出写入<code>mr-out-x</code>文件中</li>
<li>正确的输出格式应为：<br><code>fmt.Fprintf(ofile, &quot;%v %v\n&quot;, intermediate[i].Key, output)</code></li>
<li>Map的intermediate输出应存放在当前目录中，便于随后读取作为reduce task的输入</li>
<li><code>mr/coordinator.go</code>应实现一个<code>Done()</code>方法，MapReduce结束后返回true退出程序，可以通过<code>call()</code>方法的返回值来告知worker</li>
</ol>
<h3 id="3-Lab实现"><a href="#3-Lab实现" class="headerlink" title="3. Lab实现"></a>3. Lab实现</h3><h4 id="1-Worker和Master通过RPC实现信息交换"><a href="#1-Worker和Master通过RPC实现信息交换" class="headerlink" title="1. Worker和Master通过RPC实现信息交换"></a>1. Worker和Master通过RPC实现信息交换</h4><p>worker向master请求分配task, master选择合适的task分配给worker; worker完成task后告知master, master将task标记为已完成</p>
<p><strong>1.1 RPC-远程过程调用</strong></p>
<p>RPC - Remote Procedure Call, 是一个计算机通信协议, 该协议允许本地程序调用另一个地址空间(通常为一个开放网络的一台计算机,Lab中为<code>worker.go</code>调用运行在<code>master.go</code>的方法)的子程序, 远端程序执行完毕后返回调用结果到本地程序</p>
<p><img src="/.com//rpc.png" alt="RPC"></p>
<p>Lab中主要通过<code>Call</code>函数实现RPC机制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call(rpcname string, args interface&#123;&#125;, reply interface&#123;&#125;) bool</span><br></pre></td></tr></table></figure>

<p>rpcname: 远程调用的方法(必须是导出的-首字母大写)<br>args: 远程调用方法接受的参数<br>reply: 远程调用方法返回的参数</p>
<p><code>Master.go</code>中首先通过<code>MakeMaster</code>函数实例化了一个Master对象, 并注册了rpc服务, 然后把rpc挂载到http服务上, 在本地网络上侦听来自<code>worker.go</code>的调用信息</p>
<p><code>worker.go</code>中首先与RPC服务器建立连接, 随后调用<code>master.go</code>的方法并等待返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpc.Register(m) // 注册roc服务</span><br><span class="line">rpc.HandleHTTP() // 挂载</span><br><span class="line">l, e := net.Listen(&quot;unix&quot;, sockname)</span><br><span class="line">go http.Serve(l, nil) // 侦听来自sockname的调用</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c, err := rpc.DialHTTP(&quot;unix&quot;, sockname) // 与rpc服务器建立连接</span><br><span class="line">c.Call(rpcname, args, reply) // 远程调用方法</span><br></pre></td></tr></table></figure>

<p><strong>1.2 Worker-&gt;Master</strong></p>
<p>worker-&gt;master的通信主要包括两部分: 请求任务和告知任务完成</p>
<p>分别由<code>CallTask()</code>和<code>CallTaskDone()</code>方法实现, 通过RPC服务对应调用<code>master.go</code>中的<code>AskTask()</code>和<code>AskDone()</code>方法</p>
<p>这里的TaskInfo是一个结构体对象, 描述了master分配task的具体信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">type TaskInfo struct &#123;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	    task state(declared in const above):</span><br><span class="line">	        0 - map</span><br><span class="line">	        1 - reduce</span><br><span class="line">	        2 - wait</span><br><span class="line">	        3 - end</span><br><span class="line">	*/</span><br><span class="line">	State int</span><br><span class="line"></span><br><span class="line">	FileName  string  // task file name</span><br><span class="line">	FileIndex int     // map task index(0 - NFiles-1)</span><br><span class="line">	PartIndex int     // reduce task index(0 - NReduce-1)</span><br><span class="line"></span><br><span class="line">	NReduce int       // reduce task number</span><br><span class="line">	NFiles  int       // map task number</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过RPC远程调用<code>AskTask()</code>函数, reply接受<code>AskTask()</code>生成的TaskInfo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func CallTask() *TaskInfo &#123;</span><br><span class="line"></span><br><span class="line">	// declare an argument structure</span><br><span class="line">	args := TaskArgs&#123;&#125;</span><br><span class="line"></span><br><span class="line">	// declare an reply structure</span><br><span class="line">	reply := TaskInfo&#123;&#125;</span><br><span class="line"></span><br><span class="line">	// send the RPC request, wait for the reply.</span><br><span class="line">	call(&quot;Master.AskTask&quot;, &amp;args, &amp;reply)</span><br><span class="line"></span><br><span class="line">	return &amp;reply</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>worker应该不断尝试向master请求新的任务信息, 并对传回的TaskInfo进行处理, 直到收到master传回的TaskEnd信息 (表示所有task均已完成)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line"></span><br><span class="line">    task := CallTask()</span><br><span class="line">    switch task.State &#123;</span><br><span class="line"></span><br><span class="line">    case TaskMap:</span><br><span class="line">        workerMap(mapf, task)</span><br><span class="line"></span><br><span class="line">    case TaskReduce:</span><br><span class="line">        workerReduce(reducef, task)</span><br><span class="line"></span><br><span class="line">    case TaskWait:</span><br><span class="line">        time.Sleep(time.Duration(time.Second * 5))</span><br><span class="line"></span><br><span class="line">    case TaskEnd:</span><br><span class="line">        fmt.Printf(&quot;all tasks complete.....\n&quot;)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">        panic(&quot;Worker error...&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>worker每完成一个任务, 都应该向master告知任务已完成, master进行对应处理, 同样通过RPC远程调用<code>AskDone()</code>函数, 参数args为对应任务的TaskInfo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func CallTaskDone(taskinfo *TaskInfo) &#123;</span><br><span class="line"></span><br><span class="line">	reply := ExampleReply&#123;&#125;</span><br><span class="line"></span><br><span class="line">	call(&quot;Master.AskDone&quot;, taskinfo, &amp;reply)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.3 Master-&gt;Worker</strong></p>
<p>map和reduce是两种不同的task, 因此需要定义一个任务类接口, 并由两个不同的类实现; 此外, 还需定义一个任务队列类, 以实现任务的入列出列等操作</p>
<p>任务类接口:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type TaskInterface interface &#123;</span><br><span class="line">    GenerateTaskInfo() TaskInfo</span><br><span class="line">    OutOfTime() bool</span><br><span class="line">    GetFileIndex() int</span><br><span class="line">    GetPartIndex() int</span><br><span class="line">    SetNow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口实现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type TaskStat struct &#123;</span><br><span class="line">    beginTime time.Time</span><br><span class="line">    fileName  string</span><br><span class="line">    fileIndex int</span><br><span class="line">    partIndex int</span><br><span class="line">    nReduce   int</span><br><span class="line">    nFiles    int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type MapTaskStat struct &#123;</span><br><span class="line">    TaskStat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ReduceTaskStat struct &#123;</span><br><span class="line">    TaskStat</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>MapTaskStat类和ReduceTaskStat类中包含了TaskStat类, 可以视为继承了TaskStat类, 享有内部的方法和变量</p>
<p>Go语言中的多态可以通过接口实现, MapTaskStat类和ReduceTaskStat类都实现了TaskInterface接口(实现了隐式的向上转型), 从而可以调用相同接口方法的不同实现</p>
<p>任务队列:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type TaskQueue struct &#123;</span><br><span class="line">    taskArray []TaskInterface</span><br><span class="line">    mutex     sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type Master struct &#123;</span><br><span class="line"></span><br><span class="line">    filename []string</span><br><span class="line"></span><br><span class="line">    // map task queue</span><br><span class="line">    mapTaskWaiting TaskQueue</span><br><span class="line">    mapTaskRunning TaskQueue</span><br><span class="line"></span><br><span class="line">    // reduce task queue</span><br><span class="line">    reduceTaskWaiting TaskQueue</span><br><span class="line">    reduceTaskRunning TaskQueue</span><br><span class="line"></span><br><span class="line">    // state</span><br><span class="line">    isDone  bool</span><br><span class="line">    nReduce int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务队列类中包含一个TaskInterface数组和一个mutex互斥锁, 实现了一系列队列操作(Pop, Push, Remove, Size), mutex互斥锁确保同一时间只有一个线程在操作任务队列</p>
<p>(任务队列通过链表实现, mutex互斥锁通过chan实现会更好)</p>
<p>队列操作实现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// mutex lock and unlock</span><br><span class="line"></span><br><span class="line">func (t *TaskQueue) lock() &#123;</span><br><span class="line">    t.mutex.Lock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t *TaskQueue) unlock() &#123;</span><br><span class="line">    t.mutex.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务队列入队, 出队 (先入先出)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func (t *TaskQueue) Pop() TaskInterface &#123;</span><br><span class="line">    t.lock()</span><br><span class="line">    arraylength := len(t.taskArray)</span><br><span class="line">    if arraylength == 0 &#123;</span><br><span class="line">        t.unlock()</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    ret := t.taskArray[0]</span><br><span class="line">    t.taskArray = t.taskArray[1:arraylength]</span><br><span class="line">    t.unlock()</span><br><span class="line">    return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t *TaskQueue) Push(task TaskInterface) &#123;</span><br><span class="line">    t.lock()</span><br><span class="line">    if task == nil &#123;</span><br><span class="line">        t.unlock()</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    t.taskArray = append(t.taskArray, task)</span><br><span class="line">    t.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从任务队列中移除任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func (t *TaskQueue) RemoveTask(fileIndex int, partIndex int) &#123;</span><br><span class="line">    t.lock()</span><br><span class="line">    arraylength := len(t.taskArray)</span><br><span class="line">    for index := 0; index &lt; arraylength; &#123;</span><br><span class="line">        // current task</span><br><span class="line">        task := t.taskArray[index]</span><br><span class="line">        if fileIndex == task.GetFileIndex() &amp;&amp; partIndex == task.GetPartIndex() &#123;</span><br><span class="line">            // if the task is the last one in queue</span><br><span class="line">            // avoid array out of bounds</span><br><span class="line">            if index == arraylength-1 &#123;</span><br><span class="line">                t.taskArray = t.taskArray[:arraylength-1]</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                t.taskArray = append(t.taskArray[:index], t.taskArray[index+1:]...)</span><br><span class="line">            &#125;</span><br><span class="line">            break</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            index++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>对应的master-&gt;worker的通信也包含两部分: 分配任务和处理已完成任务</p>
<p>分别由<code>AskTask()</code>和<code>AskDone()</code>方法实现</p>
<p><code>AskTask()</code>方法根据当前任务完成情况处理worker的请求</p>
<ol>
<li>当前所有task均已完成</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// check for isDone</span><br><span class="line">if m.isDone &#123;</span><br><span class="line">    reply.State = TaskEnd</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>当前还有map task未完成</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// check for map tasks</span><br><span class="line">mapTask := m.mapTaskWaiting.Pop()</span><br><span class="line">if mapTask != nil &#123;</span><br><span class="line">    // record maptask begin time</span><br><span class="line">    mapTask.SetNow()</span><br><span class="line">    // append it to mapTaskRunningQueue</span><br><span class="line">    m.mapTaskRunning.Push(mapTask)</span><br><span class="line">    // generate maptask info</span><br><span class="line">    *reply = mapTask.GenerateTaskInfo()</span><br><span class="line">    fmt.Printf(&quot;Distributing map task on %vth file %v\n&quot;, reply.FileIndex, reply.FileName)</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>当前还有reduce task未完成</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// check for reduce tasks</span><br><span class="line">reduceTask := m.reduceTaskWaiting.Pop()</span><br><span class="line">if reduceTask != nil &#123;</span><br><span class="line">    // record reducetask begin time</span><br><span class="line">    reduceTask.SetNow()</span><br><span class="line">    // append it to reduceTaskRunningQueue</span><br><span class="line">    m.reduceTaskRunning.Push(reduceTask)</span><br><span class="line">    // generate reducetask info</span><br><span class="line">    *reply = reduceTask.GenerateTaskInfo()</span><br><span class="line">    fmt.Printf(&quot;Distributing reduce task on part %v %vth file %v\n&quot;, reply.PartIndex, reply.FileIndex, reply.FileName)</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>当前所有task均在进行中</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if m.mapTaskRunning.Size() &gt; 0 || m.reduceTaskRunning.Size() &gt; 0 &#123;</span><br><span class="line">    // wait for new tasks</span><br><span class="line">    reply.State = TaskWait</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AskDone()</code>方法根据当前完成task的类型 (map/reduce)进行不同的处理</p>
<p>完成map task, master将该任务从mapTaskRunning队列中移除, 如果此时没有map task正在执行或等待执行, 则开始执行reduce task</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">case TaskMap:</span><br><span class="line">    fmt.Printf(&quot;Map task on %v file %v complete\n&quot;, args.FileIndex, args.FileName)</span><br><span class="line">    m.mapTaskRunning.RemoveTask(args.FileIndex, args.PartIndex)</span><br><span class="line">    if m.mapTaskRunning.Size() == 0 &amp;&amp; m.mapTaskWaiting.Size() == 0 &#123;</span><br><span class="line">        // all map tasks done</span><br><span class="line">        // can distribute reduce tasks</span><br><span class="line">        m.DistributeReduce()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>完成reduce task, master将该任务从reduceTaskRunning队列中移除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case TaskReduce:</span><br><span class="line">    fmt.Printf(&quot;Reduce task on %v part complete\n&quot;, args.PartIndex)</span><br><span class="line">    m.reduceTaskRunning.RemoveTask(args.FileIndex, args.PartIndex)</span><br></pre></td></tr></table></figure>

<h4 id="2-Map和Reduce实现"><a href="#2-Map和Reduce实现" class="headerlink" title="2. Map和Reduce实现"></a>2. Map和Reduce实现</h4><p><strong>2.1 文件输入和输出</strong></p>
<p>从测试脚本文件<code>test-mr.sh</code>中可以发现, 在加载完MapReduce插件后, 分别执行了<code>mrmaster.go</code>和<code>mrworker.go</code>文件, </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(cd .. &amp;&amp; go build $RACE mrmaster.go) || exit 1</span><br><span class="line">(cd .. &amp;&amp; go build $RACE mrworker.go) || exit 1</span><br><span class="line">...</span><br><span class="line">timeout -k 2s 180s ../mrmaster ../pg*txt &amp;</span><br><span class="line">...</span><br><span class="line"># start multiple workers.</span><br><span class="line">timeout -k 2s 180s ../mrworker ../../mrapps/wc.so &amp;</span><br><span class="line">timeout -k 2s 180s ../mrworker ../../mrapps/wc.so &amp;</span><br><span class="line">timeout -k 2s 180s ../mrworker ../../mrapps/wc.so &amp;</span><br></pre></td></tr></table></figure>

<p><code>mrmaster.go</code>中调用了<code>master.go</code>中的<code>MakeMaster()</code>方法, 指定了输入文件 (命令行参数)和NReduce的值</p>
<p>输入文件为当前目录下(src/main/)所有以pg开头, txt结尾的文件, 命令末端的’&amp;’字符表示此进程为后台进程</p>
<p><img src="/.com//txt.png" alt="txt"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := mr.MakeMaster(os.Args[1:], 10)</span><br></pre></td></tr></table></figure>

<p>MakeMaster()方法创建并初始化了一个Master对象和一个map任务队列, 并开启了两个线程, 一个用于计时并处理超时任务, 一个用于侦听来自worker的请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// create map task queue</span><br><span class="line">mapArray := make([]TaskInterface, 0)</span><br><span class="line">    for index, file := range files &#123;</span><br><span class="line">        mapTask := MapTaskStat&#123;</span><br><span class="line">        TaskStat&#123;</span><br><span class="line">            fileName:  file,</span><br><span class="line">            fileIndex: index,</span><br><span class="line">            partIndex: 0,</span><br><span class="line">            nReduce:   nReduce,</span><br><span class="line">            nFiles:    len(file),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    mapArray = append(mapArray, &amp;mapTask)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// create master</span><br><span class="line">m := Master&#123;</span><br><span class="line">    filename: files,</span><br><span class="line">    mapTaskWaiting: TaskQueue&#123;</span><br><span class="line">        taskArray: mapArray,</span><br><span class="line">    &#125;,</span><br><span class="line">    isDone:  false,</span><br><span class="line">    nReduce: nReduce,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行完所有map task后, 调用<code>DistributeReduce()</code>方法创建NReduce个reduceTask对象并编号, 然后加入到reduceTaskWaiting队列中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">reduceTask := ReduceTaskStat&#123;</span><br><span class="line">    TaskStat&#123;</span><br><span class="line">	fileIndex: 0,</span><br><span class="line">	partIndex: 0,</span><br><span class="line">	nReduce:   m.nReduce,</span><br><span class="line">	nFiles:    len(m.filename),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for index := 0; index &lt; m.nReduce; index++ &#123;</span><br><span class="line">    task := reduceTask</span><br><span class="line">    task.partIndex = index</span><br><span class="line">    m.reduceTaskWaiting.Push(&amp;task)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mrworker.go</code>中调用了<code>worker.go</code>中的<code>Worker</code>方法, 通过plugin库加载了动态文件<code>wc.so</code>中的Map和Reduce方法作为<code>Worker</code>方法的参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mapf, reducef := loadPlugin(os.Args[1])</span><br><span class="line">mr.Worker(mapf, reducef)</span><br></pre></td></tr></table></figure>

<p>Master接收NFiles个输入txt文件, 对每个map worker分配一个txt文件, 第fileIndex个文件对应第fileIndex个map task;</p>
<p>map worker从txt文件中提取出键值对, 并将键值对划分为NReduce个(临时)文件, 存储在当前目录下, 命名为mr-fileIndex-partIndex;</p>
<p>第partIndex个reduce task读取所有名为mr-*-partIndex的文件, 将它们合并排序, 生成输出文件mr-out-partIndex (测试脚本中将partIndex个输出文件合并得到mr-wc-all)</p>
<p><strong>2.2 Map实现</strong></p>
<p>主要通过workerMap()方法实现:<br><code>workerMap(mapf func(string, string) []KeyValue, taskinfo *TaskInfo)</code><br>Worker()中接收到标记(state)为TaskMap的TaskInfo后, 将mapf方法和TaskInfo对象作为参数调用workerMap()方法</p>
<p>workerMap()方法首先读取txt文件的所有内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(taskinfo.FileName)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    log.Fatalf(&quot;Can not open file %v\n&quot;, taskinfo.FileName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">content, err := ioutil.ReadAll(file)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    log.Fatalf(&quot;Can not read file %v\n&quot;, taskinfo.FileName)</span><br><span class="line">&#125;</span><br><span class="line">file.Close()</span><br></pre></td></tr></table></figure>

<p>然后调用mapf方法提取得到键值对数组, 并将键值对数组分为NReduce份, 对键值对进行json编码后得到NReduce个(临时)输出文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">kva := mapf(taskinfo.FileName, string(content))</span><br><span class="line">intermediate = append(intermediate, kva...)</span><br><span class="line"></span><br><span class="line">// distribute keys among mr-fileindex-*</span><br><span class="line">for _, kv := range intermediate &#123;</span><br><span class="line"></span><br><span class="line">    // get key/value pair reduce task number</span><br><span class="line">    outindex := ihash(kv.Key) % nReduce</span><br><span class="line">    // file = outfiles[outindex]</span><br><span class="line">    enc := fileEncs[outindex]</span><br><span class="line"></span><br><span class="line">    // convert key/value pair to JSON</span><br><span class="line">    err := enc.Encode(&amp;kv)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Printf(&quot;file %v key %v value %v Error %v\n&quot;, taskinfo.FileName, kv.Key, kv.Value, err)</span><br><span class="line">        panic(&quot;Json encode error&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.3 Reduce实现</strong></p>
</font>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/13/socket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DaiWei Jia">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Comethru">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/13/socket/" class="post-title-link" itemprop="url">Socket</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-11-13 10:57:25 / Modified: 12:58:47" itemprop="dateCreated datePublished" datetime="2021-11-13T10:57:25+08:00">2021-11-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Java端和Python端实现Socket通信"><a href="#Java端和Python端实现Socket通信" class="headerlink" title="Java端和Python端实现Socket通信"></a>Java端和Python端实现Socket通信</h2><p><strong>需求</strong>：课程项目需要实现一个web端的图像识别功能，用户访问网站识别页面，本地上传需要识别的图像文件，点击提交按钮后Java后端将图片传输到Python图像识别算法模型，将预测结果传回Java并显示在网站上</p>
<h3 id="1-JavaWeb前后端实现"><a href="#1-JavaWeb前后端实现" class="headerlink" title="1. JavaWeb前后端实现"></a>1. JavaWeb前后端实现</h3><p><strong>1.1 Vue前端实现</strong></p>
<p>图像文件上传:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 域内容发生改变时调用getFile函数,这里$event是上传的文件</span><br><span class="line">&lt;input accept=&quot;image/*&quot; type=&quot;file&quot; name=&quot;image&quot; @change=&quot;getFile($event)&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;img/site/default-img.png&quot; id=&quot;input&quot; width=&quot;200px&quot; height=&quot;200px&quot;&gt;</span><br><span class="line"></span><br><span class="line">// Vue methods</span><br><span class="line">getFile: function (event)&#123;</span><br><span class="line">    this.file = event.target.files[0];</span><br><span class="line">    const src = this.getObjectUrl(this.file)</span><br><span class="line">    // 将得到的url注入到id为input的img对象中</span><br><span class="line">    document.getElementById(&#x27;input&#x27;).src = src;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">getObjectUrl: function (file)&#123;</span><br><span class="line">    let url = null;</span><br><span class="line">    url = window.URL.createObjectURL(file)</span><br><span class="line">    return url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前后端交互:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 点击提交按钮将调用upload函数</span><br><span class="line">&lt;a href=&quot;#nowhere&quot; class=&quot;btn btn-success btn-lg&quot; @click=&quot;upload&quot;&gt;提 交&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">// Vue method</span><br><span class="line">upload: function ()&#123;</span><br><span class="line">    const url = this.uri + &quot;/&quot;;</span><br><span class="line">    // axios传输文件要用formData格式</span><br><span class="line">    let formData = new FormData();</span><br><span class="line">    formData.append(&quot;image&quot;, this.file);</span><br><span class="line">    // post请求&#x27;recognitions/&#x27;地址</span><br><span class="line">    axios.post(url, formData).then(function(response)&#123;</span><br><span class="line">        // response.data是返回数据</span><br><span class="line">        vue.id = response.data</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.2 Springboot后端实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class RecognitionController &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/recognitions&quot;)</span><br><span class="line">    public int imageRecognition(@RequestParam(&quot;image&quot;) MultipartFile image) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>@RestController</code> = <code>@Controller</code> + <code>@ResponseBody</code></p>
<p><code>@Controller</code>表示该类是控制器类<br><code>@ResponseBody</code>指该类中所有数据都会以JSON字符串形式返回</p>
<p><code>@PostMapping(&quot;/recognitions&quot;)</code>捕获url为<code>/recognition</code>的post请求,并执行对应函数</p>
<p><code>@RequestParam(&quot;image&quot;) MultipartFile image</code>将<code>FormData</code>中key为image的value值绑定到参数<code>MultipartFile image</code>上</p>
<p><strong>1.2.1 向Python端发送图片数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Socket socket = null;</span><br><span class="line">try &#123;</span><br><span class="line">    InetAddress addr = InetAddress.getLocalHost();</span><br><span class="line">    String host = addr.getHostName();</span><br><span class="line">    // 创建一个流套接字并将其连接到指定主机上的指定端口号</span><br><span class="line">    socket = new Socket(host, 12345);</span><br><span class="line"></span><br><span class="line">    // // 返回一个与该socket相关联的输出流(用于向服务端发送数据)</span><br><span class="line">    OutputStream os = socket.getOutputStream();</span><br><span class="line">    ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">    byte[] bytes = image.getBytes();</span><br><span class="line">    baos.write(bytes);</span><br><span class="line"></span><br><span class="line">    PrintWriter pw = new PrintWriter(os);</span><br><span class="line">    pw.write(Base64.getEncoder().encodeToString(baos.toByteArray()));</span><br><span class="line">    // 末尾发送一个over字符串作为结束标志</span><br><span class="line">    pw.print(&quot;over&quot;);</span><br><span class="line">    // flush()将缓冲区中的内容强制输出到目的地</span><br><span class="line">    pw.flush();</span><br><span class="line">    // 关闭socket的输出流(可以正常接收返回的信息)</span><br><span class="line">    socket.shutdownOutput();</span><br></pre></td></tr></table></figure>

<p>首先与服务器(Python端)建立连接,随后创建一个输出流用于发送数据,将MultipartFile文件转换为<code>byte</code>数组,并写入<code>ByteArrayOutputStream</code>,最后通过<code>PrintWriter</code>调用<code>OutputStreamWriter</code>的<code>write()</code>方法发送数据(该方法会将<code>string</code>类型数据转为<code>bytes-like object</code>(?)输出到stream)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 最初的实现代码,在这个需求上显得有点多余,但可以作为通过socket发送本地文件的思路</span><br><span class="line">// 大致流程为先将MultipartFile文件存到本地(可以通过临时文件),然后通过文件输入流读取文件数据写入到baos中输出</span><br><span class="line"></span><br><span class="line">File file = new File(&quot;D:/IdeaProjects&quot;, &quot;temp&quot;+&quot;.jpg&quot;);</span><br><span class="line">if(!file.getParentFile().exists()) file.getParentFile().mkdirs();</span><br><span class="line">// transferTo()将接收文件传输到指定目录</span><br><span class="line">image.transferTo(file);</span><br><span class="line">BufferedImage img = ImageUtil.change2jpg(file);</span><br><span class="line">ImageIO.write(img, &quot;jpg&quot;, file);</span><br><span class="line"></span><br><span class="line">// 创建FileInputStream对象并与要读取的文件相关联</span><br><span class="line">FileInputStream fis = new FileInputStream(&quot;D:/IdeaProjects/temp.jpg&quot;);</span><br><span class="line"></span><br><span class="line">// 通过read方法对文件数据以字节形式进行读取</span><br><span class="line">// 随后通过write方法将读取到的len个字节写入到输出流中</span><br><span class="line">byte[] buf = new byte[1024*1024];</span><br><span class="line">    int len = 0;</span><br><span class="line">    while ((len=fis.read(buf)) != -1)&#123;</span><br><span class="line">        baos.write(buf, 0, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 后续内容大致相同</span><br></pre></td></tr></table></figure>

<p><strong>1.2.2 接收Python传回的数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 返回一个与该socket相关联的输入流(接收服务器传回的数据)</span><br><span class="line">InputStream is = socket.getInputStream();</span><br><span class="line">// InputStreamReader将字节流转为字符流</span><br><span class="line">// BufferedReader从字符输入流中读取数据置入缓冲区(缓冲区大小可指定,默认8kb)</span><br><span class="line">BufferedReader br = new BufferedReader(new InputStreamReader(is, &quot;UTF-8&quot;));</span><br><span class="line">// 从缓冲区中读取一行数据</span><br><span class="line">String pred = br.readLine();</span><br><span class="line">int result = Integer.parseInt(pred);</span><br></pre></td></tr></table></figure>

<p>由于Python端传回的数据是一个数字(0-9),因此这里不需要对是否读取完成进行判断,直接将读取得到的<code>string</code>转为<code>int</code>即可</p>
<p>此外这里也可以使用<code>br.read()</code>函数,该函数读取一个字符,返回该字符对应的asc码值</p>
<p>最后关闭socket连接和所有开启的输入输出流即可</p>
<h3 id="2-服务器端-Python-实现"><a href="#2-服务器端-Python-实现" class="headerlink" title="2.服务器端(Python)实现"></a>2.服务器端(Python)实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 创建服务器套接字</span><br><span class="line">serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"># 获取本地主机名称</span><br><span class="line">host = socket.gethostname()</span><br><span class="line"># 设置一个端口</span><br><span class="line">port = 12345</span><br><span class="line"># 将套接字与本地主机和端口绑定</span><br><span class="line">serversocket.bind((host, port))</span><br><span class="line"># 设置监听最大连接数</span><br><span class="line">serversocket.listen(5)</span><br><span class="line"># 获取本地服务器的连接信息</span><br><span class="line">myaddr = serversocket.getsockname()</span><br><span class="line">print(&quot;服务器地址:%s&quot; % str(myaddr))</span><br></pre></td></tr></table></figure>

<p>首先创建TCP Socket,设置端口号并与本地主机绑定,随后服务器端等待客户端发起连接,并为每个TCP连接开启一个处理线程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">while True:</span><br><span class="line">    # 接收TCP连接并返回(conn,address)</span><br><span class="line">    # 其中conn是用于接收和发送数据的套接字对象</span><br><span class="line">    # addr是连接客户端的地址</span><br><span class="line">    clientsocket, addr = serversocket.accept()</span><br><span class="line">    print(&quot;连接地址:%s&quot; % str(addr))</span><br><span class="line">    try:</span><br><span class="line">        # 为每一个请求开启一个处理线程</span><br><span class="line">        t = ServerThreading(clientsocket)</span><br><span class="line">        t.start()</span><br><span class="line">        pass</span><br><span class="line">    except Exception as identifier:</span><br><span class="line">        print(identifier)</span><br><span class="line">        pass</span><br><span class="line">    pass</span><br><span class="line">serversocket.close()</span><br></pre></td></tr></table></figure>

<p>ServerThreading实现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;开启线程......&#x27;)</span><br><span class="line">try:</span><br><span class="line"># 接收客户端传来的数据</span><br><span class="line">msg = &#x27;&#x27;</span><br><span class="line">while True:</span><br><span class="line">    # 读取recvsize个字节</span><br><span class="line">    data = self._socket.recv(self._recvsize)</span><br><span class="line">    # 解码(bytes-&gt;string)</span><br><span class="line">    msg += data.decode(self._encoding)</span><br><span class="line">    # 读取到的数据以over结尾,表示接收完毕</span><br><span class="line">    if msg.strip().endswith(&#x27;over&#x27;):</span><br><span class="line">        msg = msg[:-4]</span><br><span class="line">        break</span><br><span class="line">    pass</span><br><span class="line"># 对经base64编码的对象进行解码</span><br><span class="line">msg = base64.b64decode(msg)</span><br><span class="line"># &#x27;wb&#x27;-二进制写模式,会先删除文件中现有内容</span><br><span class="line">file = open(&#x27;atsdd.jpg&#x27;, &#x27;wb&#x27;)</span><br><span class="line"># 将bytes数据写入file</span><br><span class="line">file.write(msg)</span><br><span class="line">file.close()</span><br><span class="line">img = Image.open(&#x27;atsdd.jpg&#x27;)</span><br><span class="line"># img = Image.fromarray(np_arr)</span><br><span class="line"># img.save(&#x27;atsdd.jpg&#x27;)</span><br><span class="line"></span><br><span class="line">model = torch.load(&#x27;D:/python workplace/ATSDD.pth&#x27;)</span><br><span class="line">transform = ImageTransform(size, mean, std)</span><br><span class="line">img = transform(img, phase=&#x27;val&#x27;).unsqueeze(0).to(device)</span><br><span class="line"></span><br><span class="line">model.eval()</span><br><span class="line">output = model(img)</span><br><span class="line">result = torch.max(output, 1)[1]</span><br><span class="line"></span><br><span class="line">returnmessage = str(result.cpu().numpy()[0])</span><br><span class="line">self._socket.send(returnmessage.encode(self._encoding))</span><br></pre></td></tr></table></figure>

<p>建立连接后开始读取客户端传来的数据,<code>recv()</code>函数接受TCP套接字的数据,返回值是<code>bytes-like object</code>类似字节对象;</p>
<p>随后通过decode函数以指定的编码格式(这里是utf-8)解码<code>bytes-like</code>对象,返回解码后的字符串,并检查字符串的最后四位,如果是’over’则表示完成数据接收;</p>
<p>最后通过<code>b64decode()</code>方法解码字符串,这里的字符串是由经base64编码的<code>byte[]</code>转换而来;将解码得到的bytes数据写入file得到图片,并作为参数放入图像识别模型中,传回预测结果</p>
<p>数据类型转换流程:</p>
<p><strong>Java端:</strong> </p>
<p><code>getBytes(): </code></p>
<p>MultipartFile -&gt; byte[]</p>
<p><code>Base64.getEncoder().encodeToString(baos.toByteArray()): </code></p>
<p>byte[] -&gt; bytes-like object -&gt; string</p>
<p><code>pw.write():</code></p>
<p>string -&gt; char[] -&gt; bytes-like object</p>
<p><strong>Python端:</strong></p>
<p><code>socket.recv().decode():</code> </p>
<p>bytes-like object -&gt; string</p>
<p><code>base64.b64decode():</code> </p>
<p>string -&gt; bytes</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/20/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DaiWei Jia">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Comethru">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/20/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-20 14:07:29" itemprop="dateCreated datePublished" datetime="2021-08-20T14:07:29+08:00">2021-08-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-08-21 09:54:48" itemprop="dateModified" datetime="2021-08-21T09:54:48+08:00">2021-08-21</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DaiWei Jia</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
