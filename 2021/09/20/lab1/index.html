<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","version":"8.7.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>
<meta name="description" content="Lab1 MapReduceMapReduce(2004)Lab1 MapReduceLab1 Video1. 实验环境准备  1git clone git:&#x2F;&#x2F;g.csail.mit.edu&#x2F;6.824-golabs-2020 6.824lab lab1 提供了一个顺序（非分布式）的MapReduce实现在 src&#x2F;main&#x2F;mrsequential.go中，还提供了两个MapReduce应用：">
<meta property="og:type" content="article">
<meta property="og:title" content="6.824 lab1 MapReduce">
<meta property="og:url" content="http://example.com/2021/09/20/lab1/index.html">
<meta property="og:site_name" content="Comethru">
<meta property="og:description" content="Lab1 MapReduceMapReduce(2004)Lab1 MapReduceLab1 Video1. 实验环境准备  1git clone git:&#x2F;&#x2F;g.csail.mit.edu&#x2F;6.824-golabs-2020 6.824lab lab1 提供了一个顺序（非分布式）的MapReduce实现在 src&#x2F;main&#x2F;mrsequential.go中，还提供了两个MapReduce应用：">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2021/09/20/lab1/img/mapreduce.png">
<meta property="og:image" content="http://example.com/2021/09/20/lab1/img/rpc.png">
<meta property="og:image" content="http://example.com/2021/09/20/lab1/img/txt.png">
<meta property="article:published_time" content="2021-09-20T12:51:55.159Z">
<meta property="article:modified_time" content="2021-09-20T13:36:34.161Z">
<meta property="article:author" content="DaiWei Jia">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/09/20/lab1/img/mapreduce.png">


<link rel="canonical" href="http://example.com/2021/09/20/lab1/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2021/09/20/lab1/","path":"2021/09/20/lab1/","title":"6.824 lab1 MapReduce"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>6.824 lab1 MapReduce | Comethru</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Comethru</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab1-MapReduce"><span class="nav-number">1.</span> <span class="nav-text">Lab1 MapReduce</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MapReduce-2004"><span class="nav-number">1.0.1.</span> <span class="nav-text">MapReduce(2004)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lab1-MapReduce-1"><span class="nav-number">1.0.2.</span> <span class="nav-text">Lab1 MapReduce</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lab1-Video"><span class="nav-number">1.0.3.</span> <span class="nav-text">Lab1 Video</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="nav-number">1.1.</span> <span class="nav-text">1. 实验环境准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BB%BB%E5%8A%A1%E8%AF%B4%E6%98%8E"><span class="nav-number">1.2.</span> <span class="nav-text">2. 任务说明</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E4%BA%8ELab%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E5%AE%9A"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">关于Lab的一些规定</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Lab%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.</span> <span class="nav-text">3. Lab实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Worker%E5%92%8CMaster%E9%80%9A%E8%BF%87RPC%E5%AE%9E%E7%8E%B0%E4%BF%A1%E6%81%AF%E4%BA%A4%E6%8D%A2"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. Worker和Master通过RPC实现信息交换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Map%E5%92%8CReduce%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. Map和Reduce实现</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">DaiWei Jia</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/20/lab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DaiWei Jia">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Comethru">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          6.824 lab1 MapReduce
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-09-20 20:51:55 / Modified: 21:36:34" itemprop="dateCreated datePublished" datetime="2021-09-20T20:51:55+08:00">2021-09-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="Lab1-MapReduce"><a href="#Lab1-MapReduce" class="headerlink" title="Lab1 MapReduce"></a>Lab1 MapReduce</h2><h4 id="MapReduce-2004"><a href="#MapReduce-2004" class="headerlink" title="MapReduce(2004)"></a><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf">MapReduce(2004)</a></h4><h4 id="Lab1-MapReduce-1"><a href="#Lab1-MapReduce-1" class="headerlink" title="Lab1 MapReduce"></a><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/labs/lab-mr.html">Lab1 MapReduce</a></h4><h4 id="Lab1-Video"><a href="#Lab1-Video" class="headerlink" title="Lab1 Video"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1R7411t71W">Lab1 Video</a></h4><h3 id="1-实验环境准备"><a href="#1-实验环境准备" class="headerlink" title="1. 实验环境准备"></a>1. 实验环境准备</h3><font size=4>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://g.csail.mit.edu/6.824-golabs-2020 6.824lab</span><br></pre></td></tr></table></figure>
<p>lab1 提供了一个顺序（非分布式）的MapReduce实现在 <code>src/main/mrsequential.go</code>中，还提供了两个MapReduce应用：词频统计 <code>mrapps/wc.go</code> 和文本索引 <code>mrapps/index.go</code></p>
<p>可以通过以下代码运行: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/6.824</span><br><span class="line">$ cd src/main</span><br><span class="line">$ go build -race -buildmode=plugin ../mrapps/wc.go</span><br><span class="line">$ rm mr-out*</span><br><span class="line">$ go run -race mrsequential.go wc.so pg*.txt</span><br><span class="line">$ more mr-out-0</span><br><span class="line">A 509</span><br><span class="line">ABOUT 2</span><br><span class="line">ACT 8</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><img src="img/mapreduce.png" alt="MapReduce"></p>
<p>这是<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf">MapReduce论文</a>中给出的MapReduce流程图</p>
<ol>
<li>用户程序将输入文件划分为M份 (这里的M可调控)，随后在一组机器上启动该程序的许多副本，其中一个为Master，剩下的为map worker和reduce worker，Master将M份任务中的一份分配给空闲的map worker</li>
<li>map worker将输入数据传入map函数，map函数从输入数据中解析出key/value对输出intermediate (可能以key/value形式存在)并将其写入本地磁盘</li>
<li>通过分区函数将本地磁盘的缓存对划分为R个区域 ，并将这些区域的地址传回Master，Master将这些地址转发给reduce worker</li>
<li>reduce worker读取区域中的intermediate数据，通过排序函数按key排序后，将有相同key的value放入一个集合中，将key和value集合传入reduce函数，reduce函数返回每个key对应value集合相加的值，写入输出文件</li>
<li>汇总所有reduce task的输出文件得到最终的词频数据</li>
</ol>
<h3 id="2-任务说明"><a href="#2-任务说明" class="headerlink" title="2. 任务说明"></a>2. 任务说明</h3><p>实现一个分布式的MapReduce程序，一个Master，多个Worker并行执行task，Worker和Master通过RPC对话</p>
<p>Worker通过RPC向Master请求task，完成task后通过RPC告知Master；Master应对Worker执行task的时间进行把控，超时则将task分配给其它Worker</p>
<p>通过在<code>mr/master.go</code>,<code>mr/worker.go</code>和<code>mr/rpc.go</code>中编写代码实现MapReduce</p>
<p>通过<code>bash test-mr.sh</code>测试脚本检查代码正确性</p>
<h5 id="关于Lab的一些规定"><a href="#关于Lab的一些规定" class="headerlink" title="关于Lab的一些规定"></a>关于Lab的一些规定</h5><ol>
<li>Map阶段应将intermediate划分为<code>nReduce</code>个reduce task，其中<code>nReduce</code>由<code>main/mrmaster.go</code>中<code>MakeMaster()</code>的参数指定</li>
<li>应将第x个reduce task的输出写入<code>mr-out-x</code>文件中</li>
<li>正确的输出格式应为：<br><code>fmt.Fprintf(ofile, &quot;%v %v\n&quot;, intermediate[i].Key, output)</code></li>
<li>Map的intermediate输出应存放在当前目录中，便于随后读取作为reduce task的输入</li>
<li><code>mr/coordinator.go</code>应实现一个<code>Done()</code>方法，MapReduce结束后返回true退出程序，可以通过<code>call()</code>方法的返回值来告知worker</li>
</ol>
<h3 id="3-Lab实现"><a href="#3-Lab实现" class="headerlink" title="3. Lab实现"></a>3. Lab实现</h3><h4 id="1-Worker和Master通过RPC实现信息交换"><a href="#1-Worker和Master通过RPC实现信息交换" class="headerlink" title="1. Worker和Master通过RPC实现信息交换"></a>1. Worker和Master通过RPC实现信息交换</h4><p>worker向master请求分配task, master选择合适的task分配给worker; worker完成task后告知master, master将task标记为已完成</p>
<p><strong>1.1 RPC-远程过程调用</strong></p>
<p>RPC - Remote Procedure Call, 是一个计算机通信协议, 该协议允许本地程序调用另一个地址空间(通常为一个开放网络的一台计算机,Lab中为<code>worker.go</code>调用运行在<code>master.go</code>的方法)的子程序, 远端程序执行完毕后返回调用结果到本地程序</p>
<p><img src="img/rpc.png" alt="RPC"></p>
<p>Lab中主要通过<code>Call</code>函数实现RPC机制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call(rpcname string, args interface&#123;&#125;, reply interface&#123;&#125;) bool</span><br></pre></td></tr></table></figure>

<p>rpcname: 远程调用的方法(必须是导出的-首字母大写)<br>args: 远程调用方法接受的参数<br>reply: 远程调用方法返回的参数</p>
<p><code>Master.go</code>中首先通过<code>MakeMaster</code>函数实例化了一个Master对象, 并注册了rpc服务, 然后把rpc挂载到http服务上, 在本地网络上侦听来自<code>worker.go</code>的调用信息</p>
<p><code>worker.go</code>中首先与RPC服务器建立连接, 随后调用<code>master.go</code>的方法并等待返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpc.Register(m) // 注册roc服务</span><br><span class="line">rpc.HandleHTTP() // 挂载</span><br><span class="line">l, e := net.Listen(&quot;unix&quot;, sockname)</span><br><span class="line">go http.Serve(l, nil) // 侦听来自sockname的调用</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c, err := rpc.DialHTTP(&quot;unix&quot;, sockname) // 与rpc服务器建立连接</span><br><span class="line">c.Call(rpcname, args, reply) // 远程调用方法</span><br></pre></td></tr></table></figure>

<p><strong>1.2 Worker-&gt;Master</strong></p>
<p>worker-&gt;master的通信主要包括两部分: 请求任务和告知任务完成</p>
<p>分别由<code>CallTask()</code>和<code>CallTaskDone()</code>方法实现, 通过RPC服务对应调用<code>master.go</code>中的<code>AskTask()</code>和<code>AskDone()</code>方法</p>
<p>这里的TaskInfo是一个结构体对象, 描述了master分配task的具体信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">type TaskInfo struct &#123;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	    task state(declared in const above):</span><br><span class="line">	        0 - map</span><br><span class="line">	        1 - reduce</span><br><span class="line">	        2 - wait</span><br><span class="line">	        3 - end</span><br><span class="line">	*/</span><br><span class="line">	State int</span><br><span class="line"></span><br><span class="line">	FileName  string  // task file name</span><br><span class="line">	FileIndex int     // map task index(0 - NFiles-1)</span><br><span class="line">	PartIndex int     // reduce task index(0 - NReduce-1)</span><br><span class="line"></span><br><span class="line">	NReduce int       // reduce task number</span><br><span class="line">	NFiles  int       // map task number</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过RPC远程调用<code>AskTask()</code>函数, reply接受<code>AskTask()</code>生成的TaskInfo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func CallTask() *TaskInfo &#123;</span><br><span class="line"></span><br><span class="line">	// declare an argument structure</span><br><span class="line">	args := TaskArgs&#123;&#125;</span><br><span class="line"></span><br><span class="line">	// declare an reply structure</span><br><span class="line">	reply := TaskInfo&#123;&#125;</span><br><span class="line"></span><br><span class="line">	// send the RPC request, wait for the reply.</span><br><span class="line">	call(&quot;Master.AskTask&quot;, &amp;args, &amp;reply)</span><br><span class="line"></span><br><span class="line">	return &amp;reply</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>worker应该不断尝试向master请求新的任务信息, 并对传回的TaskInfo进行处理, 直到收到master传回的TaskEnd信息 (表示所有task均已完成)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line"></span><br><span class="line">    task := CallTask()</span><br><span class="line">    switch task.State &#123;</span><br><span class="line"></span><br><span class="line">    case TaskMap:</span><br><span class="line">        workerMap(mapf, task)</span><br><span class="line"></span><br><span class="line">    case TaskReduce:</span><br><span class="line">        workerReduce(reducef, task)</span><br><span class="line"></span><br><span class="line">    case TaskWait:</span><br><span class="line">        time.Sleep(time.Duration(time.Second * 5))</span><br><span class="line"></span><br><span class="line">    case TaskEnd:</span><br><span class="line">        fmt.Printf(&quot;all tasks complete.....\n&quot;)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">        panic(&quot;Worker error...&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>worker每完成一个任务, 都应该向master告知任务已完成, master进行对应处理, 同样通过RPC远程调用<code>AskDone()</code>函数, 参数args为对应任务的TaskInfo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func CallTaskDone(taskinfo *TaskInfo) &#123;</span><br><span class="line"></span><br><span class="line">	reply := ExampleReply&#123;&#125;</span><br><span class="line"></span><br><span class="line">	call(&quot;Master.AskDone&quot;, taskinfo, &amp;reply)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.3 Master-&gt;Worker</strong></p>
<p>map和reduce是两种不同的task, 因此需要定义一个任务类接口, 并由两个不同的类实现; 此外, 还需定义一个任务队列类, 以实现任务的入列出列等操作</p>
<p>任务类接口:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type TaskInterface interface &#123;</span><br><span class="line">    GenerateTaskInfo() TaskInfo</span><br><span class="line">    OutOfTime() bool</span><br><span class="line">    GetFileIndex() int</span><br><span class="line">    GetPartIndex() int</span><br><span class="line">    SetNow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口实现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type TaskStat struct &#123;</span><br><span class="line">    beginTime time.Time</span><br><span class="line">    fileName  string</span><br><span class="line">    fileIndex int</span><br><span class="line">    partIndex int</span><br><span class="line">    nReduce   int</span><br><span class="line">    nFiles    int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type MapTaskStat struct &#123;</span><br><span class="line">    TaskStat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ReduceTaskStat struct &#123;</span><br><span class="line">    TaskStat</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>MapTaskStat类和ReduceTaskStat类中包含了TaskStat类, 可以视为继承了TaskStat类, 享有内部的方法和变量</p>
<p>Go语言中的多态可以通过接口实现, MapTaskStat类和ReduceTaskStat类都实现了TaskInterface接口(实现了隐式的向上转型), 从而可以调用相同接口方法的不同实现</p>
<p>任务队列:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type TaskQueue struct &#123;</span><br><span class="line">    taskArray []TaskInterface</span><br><span class="line">    mutex     sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type Master struct &#123;</span><br><span class="line"></span><br><span class="line">    filename []string</span><br><span class="line"></span><br><span class="line">    // map task queue</span><br><span class="line">    mapTaskWaiting TaskQueue</span><br><span class="line">    mapTaskRunning TaskQueue</span><br><span class="line"></span><br><span class="line">    // reduce task queue</span><br><span class="line">    reduceTaskWaiting TaskQueue</span><br><span class="line">    reduceTaskRunning TaskQueue</span><br><span class="line"></span><br><span class="line">    // state</span><br><span class="line">    isDone  bool</span><br><span class="line">    nReduce int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务队列类中包含一个TaskInterface数组和一个mutex互斥锁, 实现了一系列队列操作(Pop, Push, Remove, Size), mutex互斥锁确保同一时间只有一个线程在操作任务队列</p>
<p>(任务队列通过链表实现, mutex互斥锁通过chan实现会更好)</p>
<p>队列操作实现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// mutex lock and unlock</span><br><span class="line"></span><br><span class="line">func (t *TaskQueue) lock() &#123;</span><br><span class="line">    t.mutex.Lock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t *TaskQueue) unlock() &#123;</span><br><span class="line">    t.mutex.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务队列入队, 出队 (先入先出)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func (t *TaskQueue) Pop() TaskInterface &#123;</span><br><span class="line">    t.lock()</span><br><span class="line">    arraylength := len(t.taskArray)</span><br><span class="line">    if arraylength == 0 &#123;</span><br><span class="line">        t.unlock()</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    ret := t.taskArray[0]</span><br><span class="line">    t.taskArray = t.taskArray[1:arraylength]</span><br><span class="line">    t.unlock()</span><br><span class="line">    return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t *TaskQueue) Push(task TaskInterface) &#123;</span><br><span class="line">    t.lock()</span><br><span class="line">    if task == nil &#123;</span><br><span class="line">        t.unlock()</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    t.taskArray = append(t.taskArray, task)</span><br><span class="line">    t.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从任务队列中移除任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func (t *TaskQueue) RemoveTask(fileIndex int, partIndex int) &#123;</span><br><span class="line">    t.lock()</span><br><span class="line">    arraylength := len(t.taskArray)</span><br><span class="line">    for index := 0; index &lt; arraylength; &#123;</span><br><span class="line">        // current task</span><br><span class="line">        task := t.taskArray[index]</span><br><span class="line">        if fileIndex == task.GetFileIndex() &amp;&amp; partIndex == task.GetPartIndex() &#123;</span><br><span class="line">            // if the task is the last one in queue</span><br><span class="line">            // avoid array out of bounds</span><br><span class="line">            if index == arraylength-1 &#123;</span><br><span class="line">                t.taskArray = t.taskArray[:arraylength-1]</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                t.taskArray = append(t.taskArray[:index], t.taskArray[index+1:]...)</span><br><span class="line">            &#125;</span><br><span class="line">            break</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            index++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>对应的master-&gt;worker的通信也包含两部分: 分配任务和处理已完成任务</p>
<p>分别由<code>AskTask()</code>和<code>AskDone()</code>方法实现</p>
<p><code>AskTask()</code>方法根据当前任务完成情况处理worker的请求</p>
<ol>
<li>当前所有task均已完成</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// check for isDone</span><br><span class="line">if m.isDone &#123;</span><br><span class="line">    reply.State = TaskEnd</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>当前还有map task未完成</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// check for map tasks</span><br><span class="line">mapTask := m.mapTaskWaiting.Pop()</span><br><span class="line">if mapTask != nil &#123;</span><br><span class="line">    // record maptask begin time</span><br><span class="line">    mapTask.SetNow()</span><br><span class="line">    // append it to mapTaskRunningQueue</span><br><span class="line">    m.mapTaskRunning.Push(mapTask)</span><br><span class="line">    // generate maptask info</span><br><span class="line">    *reply = mapTask.GenerateTaskInfo()</span><br><span class="line">    fmt.Printf(&quot;Distributing map task on %vth file %v\n&quot;, reply.FileIndex, reply.FileName)</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>当前还有reduce task未完成</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// check for reduce tasks</span><br><span class="line">reduceTask := m.reduceTaskWaiting.Pop()</span><br><span class="line">if reduceTask != nil &#123;</span><br><span class="line">    // record reducetask begin time</span><br><span class="line">    reduceTask.SetNow()</span><br><span class="line">    // append it to reduceTaskRunningQueue</span><br><span class="line">    m.reduceTaskRunning.Push(reduceTask)</span><br><span class="line">    // generate reducetask info</span><br><span class="line">    *reply = reduceTask.GenerateTaskInfo()</span><br><span class="line">    fmt.Printf(&quot;Distributing reduce task on part %v %vth file %v\n&quot;, reply.PartIndex, reply.FileIndex, reply.FileName)</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>当前所有task均在进行中</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if m.mapTaskRunning.Size() &gt; 0 || m.reduceTaskRunning.Size() &gt; 0 &#123;</span><br><span class="line">    // wait for new tasks</span><br><span class="line">    reply.State = TaskWait</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AskDone()</code>方法根据当前完成task的类型 (map/reduce)进行不同的处理</p>
<p>完成map task, master将该任务从mapTaskRunning队列中移除, 如果此时没有map task正在执行或等待执行, 则开始执行reduce task</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">case TaskMap:</span><br><span class="line">    fmt.Printf(&quot;Map task on %v file %v complete\n&quot;, args.FileIndex, args.FileName)</span><br><span class="line">    m.mapTaskRunning.RemoveTask(args.FileIndex, args.PartIndex)</span><br><span class="line">    if m.mapTaskRunning.Size() == 0 &amp;&amp; m.mapTaskWaiting.Size() == 0 &#123;</span><br><span class="line">        // all map tasks done</span><br><span class="line">        // can distribute reduce tasks</span><br><span class="line">        m.DistributeReduce()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>完成reduce task, master将该任务从reduceTaskRunning队列中移除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case TaskReduce:</span><br><span class="line">    fmt.Printf(&quot;Reduce task on %v part complete\n&quot;, args.PartIndex)</span><br><span class="line">    m.reduceTaskRunning.RemoveTask(args.FileIndex, args.PartIndex)</span><br></pre></td></tr></table></figure>

<h4 id="2-Map和Reduce实现"><a href="#2-Map和Reduce实现" class="headerlink" title="2. Map和Reduce实现"></a>2. Map和Reduce实现</h4><p><strong>2.1 文件输入和输出</strong></p>
<p>从测试脚本文件<code>test-mr.sh</code>中可以发现, 在加载完MapReduce插件后, 分别执行了<code>mrmaster.go</code>和<code>mrworker.go</code>文件, </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(cd .. &amp;&amp; go build $RACE mrmaster.go) || exit 1</span><br><span class="line">(cd .. &amp;&amp; go build $RACE mrworker.go) || exit 1</span><br><span class="line">...</span><br><span class="line">timeout -k 2s 180s ../mrmaster ../pg*txt &amp;</span><br><span class="line">...</span><br><span class="line"># start multiple workers.</span><br><span class="line">timeout -k 2s 180s ../mrworker ../../mrapps/wc.so &amp;</span><br><span class="line">timeout -k 2s 180s ../mrworker ../../mrapps/wc.so &amp;</span><br><span class="line">timeout -k 2s 180s ../mrworker ../../mrapps/wc.so &amp;</span><br></pre></td></tr></table></figure>

<p><code>mrmaster.go</code>中调用了<code>master.go</code>中的<code>MakeMaster()</code>方法, 指定了输入文件 (命令行参数)和NReduce的值</p>
<p>输入文件为当前目录下(src/main/)所有以pg开头, txt结尾的文件, 命令末端的’&amp;’字符表示此进程为后台进程</p>
<p><img src="img/txt.png" alt="txt"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := mr.MakeMaster(os.Args[1:], 10)</span><br></pre></td></tr></table></figure>

<p>MakeMaster()方法创建并初始化了一个Master对象和一个map任务队列, 并开启了两个线程, 一个用于计时并处理超时任务, 一个用于侦听来自worker的请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// create map task queue</span><br><span class="line">mapArray := make([]TaskInterface, 0)</span><br><span class="line">    for index, file := range files &#123;</span><br><span class="line">        mapTask := MapTaskStat&#123;</span><br><span class="line">        TaskStat&#123;</span><br><span class="line">            fileName:  file,</span><br><span class="line">            fileIndex: index,</span><br><span class="line">            partIndex: 0,</span><br><span class="line">            nReduce:   nReduce,</span><br><span class="line">            nFiles:    len(file),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    mapArray = append(mapArray, &amp;mapTask)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// create master</span><br><span class="line">m := Master&#123;</span><br><span class="line">    filename: files,</span><br><span class="line">    mapTaskWaiting: TaskQueue&#123;</span><br><span class="line">        taskArray: mapArray,</span><br><span class="line">    &#125;,</span><br><span class="line">    isDone:  false,</span><br><span class="line">    nReduce: nReduce,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行完所有map task后, 调用<code>DistributeReduce()</code>方法创建NReduce个reduceTask对象并编号, 然后加入到reduceTaskWaiting队列中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">reduceTask := ReduceTaskStat&#123;</span><br><span class="line">    TaskStat&#123;</span><br><span class="line">	fileIndex: 0,</span><br><span class="line">	partIndex: 0,</span><br><span class="line">	nReduce:   m.nReduce,</span><br><span class="line">	nFiles:    len(m.filename),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for index := 0; index &lt; m.nReduce; index++ &#123;</span><br><span class="line">    task := reduceTask</span><br><span class="line">    task.partIndex = index</span><br><span class="line">    m.reduceTaskWaiting.Push(&amp;task)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mrworker.go</code>中调用了<code>worker.go</code>中的<code>Worker</code>方法, 通过plugin库加载了动态文件<code>wc.so</code>中的Map和Reduce方法作为<code>Worker</code>方法的参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mapf, reducef := loadPlugin(os.Args[1])</span><br><span class="line">mr.Worker(mapf, reducef)</span><br></pre></td></tr></table></figure>

<p>Master接收NFiles个输入txt文件, 对每个map worker分配一个txt文件, 第fileIndex个文件对应第fileIndex个map task;</p>
<p>map worker从txt文件中提取出键值对, 并将键值对划分为NReduce个(临时)文件, 存储在当前目录下, 命名为mr-fileIndex-partIndex;</p>
<p>第partIndex个reduce task读取所有名为mr-*-partIndex的文件, 将它们合并排序, 生成输出文件mr-out-partIndex (测试脚本中将partIndex个输出文件合并得到mr-wc-all)</p>
<p><strong>2.2 Map实现</strong></p>
<p>主要通过workerMap()方法实现:<br><code>workerMap(mapf func(string, string) []KeyValue, taskinfo *TaskInfo)</code><br>Worker()中接收到标记(state)为TaskMap的TaskInfo后, 将mapf方法和TaskInfo对象作为参数调用workerMap()方法</p>
<p>workerMap()方法首先读取txt文件的所有内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(taskinfo.FileName)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    log.Fatalf(&quot;Can not open file %v\n&quot;, taskinfo.FileName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">content, err := ioutil.ReadAll(file)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    log.Fatalf(&quot;Can not read file %v\n&quot;, taskinfo.FileName)</span><br><span class="line">&#125;</span><br><span class="line">file.Close()</span><br></pre></td></tr></table></figure>

<p>然后调用mapf方法提取得到键值对数组, 并将键值对数组分为NReduce份, 对键值对进行json编码后得到NReduce个(临时)输出文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">kva := mapf(taskinfo.FileName, string(content))</span><br><span class="line">intermediate = append(intermediate, kva...)</span><br><span class="line"></span><br><span class="line">// distribute keys among mr-fileindex-*</span><br><span class="line">for _, kv := range intermediate &#123;</span><br><span class="line"></span><br><span class="line">    // get key/value pair reduce task number</span><br><span class="line">    outindex := ihash(kv.Key) % nReduce</span><br><span class="line">    // file = outfiles[outindex]</span><br><span class="line">    enc := fileEncs[outindex]</span><br><span class="line"></span><br><span class="line">    // convert key/value pair to JSON</span><br><span class="line">    err := enc.Encode(&amp;kv)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Printf(&quot;file %v key %v value %v Error %v\n&quot;, taskinfo.FileName, kv.Key, kv.Value, err)</span><br><span class="line">        panic(&quot;Json encode error&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.3 Reduce实现</strong></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/08/20/hello-world/" rel="prev" title="Hello World">
                  <i class="fa fa-chevron-left"></i> Hello World
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/11/13/socket/" rel="next" title="">
                   <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DaiWei Jia</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
