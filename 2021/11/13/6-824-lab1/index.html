<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!--<![endif]-->

<head>
  <title>6.824 lab1 MapReduce | Comethru</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Comethru">
    <meta name="author" content="DaiWei Jia">
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="Comethru" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
    
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    

    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->

  
  
  

  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            <li>
                <a class="sb-toggle-submenu">Works<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                        <li><a href="/" target="_BLANK" class="animsition-link">AAA</a></li>
                    
                        <li><a href="/atom.xml" target="_BLANK" class="animsition-link">BBB</a></li>
                    
                </ul>
            </li>
            
            
            
            <li>
                <a class="sb-toggle-submenu">Links<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                    <li><a target="_blank" rel="noopener" href="http://go.kieran.top/" class="animsition-link">Kieran</a></li>
                    
                    <li><a target="_blank" rel="noopener" href="http://domain.com/" class="animsition-link">Name</a></li>
                    
                </ul>
            </li>
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo.png" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">Comethru</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a></li>
                            
                            
                            <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a></li>
                            
                            
                            <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a></li>
                            
                            
                            <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a></li>
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->


      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2021-11-13T04:58:09.027Z" itemprop="datePublished">
          2021-11-13
      </time>
    
</span>
                <h1>6.824 lab1 MapReduce</h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<h2 id="Lab1-MapReduce"><a href="#Lab1-MapReduce" class="headerlink" title="Lab1 MapReduce"></a>Lab1 MapReduce</h2><h4 id="MapReduce-2004"><a href="#MapReduce-2004" class="headerlink" title="MapReduce(2004)"></a><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf">MapReduce(2004)</a></h4><h4 id="Lab1-MapReduce-1"><a href="#Lab1-MapReduce-1" class="headerlink" title="Lab1 MapReduce"></a><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/labs/lab-mr.html">Lab1 MapReduce</a></h4><h4 id="Lab1-Video"><a href="#Lab1-Video" class="headerlink" title="Lab1 Video"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1R7411t71W">Lab1 Video</a></h4><h3 id="1-实验环境准备"><a href="#1-实验环境准备" class="headerlink" title="1. 实验环境准备"></a>1. 实验环境准备</h3><font size="4">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://g.csail.mit.edu/6.824-golabs-2020 6.824lab</span><br></pre></td></tr></table></figure>
<p>lab1 提供了一个顺序（非分布式）的MapReduce实现在 <code>src/main/mrsequential.go</code>中，还提供了两个MapReduce应用：词频统计 <code>mrapps/wc.go</code> 和文本索引 <code>mrapps/index.go</code></p>
<p>可以通过以下代码运行: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/6.824</span><br><span class="line">$ cd src/main</span><br><span class="line">$ go build -race -buildmode=plugin ../mrapps/wc.go</span><br><span class="line">$ rm mr-out*</span><br><span class="line">$ go run -race mrsequential.go wc.so pg*.txt</span><br><span class="line">$ more mr-out-0</span><br><span class="line">A 509</span><br><span class="line">ABOUT 2</span><br><span class="line">ACT 8</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/13/6-824-lab1/mapreduce.png" alt="MapReduce"></p>
<p>这是<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf">MapReduce论文</a>中给出的MapReduce流程图</p>
<ol>
<li>用户程序将输入文件划分为M份 (这里的M可调控)，随后在一组机器上启动该程序的许多副本，其中一个为Master，剩下的为map worker和reduce worker，Master将M份任务中的一份分配给空闲的map worker</li>
<li>map worker将输入数据传入map函数，map函数从输入数据中解析出key/value对输出intermediate (可能以key/value形式存在)并将其写入本地磁盘</li>
<li>通过分区函数将本地磁盘的缓存对划分为R个区域 ，并将这些区域的地址传回Master，Master将这些地址转发给reduce worker</li>
<li>reduce worker读取区域中的intermediate数据，通过排序函数按key排序后，将有相同key的value放入一个集合中，将key和value集合传入reduce函数，reduce函数返回每个key对应value集合相加的值，写入输出文件</li>
<li>汇总所有reduce task的输出文件得到最终的词频数据</li>
</ol>
<h3 id="2-任务说明"><a href="#2-任务说明" class="headerlink" title="2. 任务说明"></a>2. 任务说明</h3><p>实现一个分布式的MapReduce程序，一个Master，多个Worker并行执行task，Worker和Master通过RPC对话</p>
<p>Worker通过RPC向Master请求task，完成task后通过RPC告知Master；Master应对Worker执行task的时间进行把控，超时则将task分配给其它Worker</p>
<p>通过在<code>mr/master.go</code>,<code>mr/worker.go</code>和<code>mr/rpc.go</code>中编写代码实现MapReduce</p>
<p>通过<code>bash test-mr.sh</code>测试脚本检查代码正确性</p>
<h5 id="关于Lab的一些规定"><a href="#关于Lab的一些规定" class="headerlink" title="关于Lab的一些规定"></a>关于Lab的一些规定</h5><ol>
<li>Map阶段应将intermediate划分为<code>nReduce</code>个reduce task，其中<code>nReduce</code>由<code>main/mrmaster.go</code>中<code>MakeMaster()</code>的参数指定</li>
<li>应将第x个reduce task的输出写入<code>mr-out-x</code>文件中</li>
<li>正确的输出格式应为：<br><code>fmt.Fprintf(ofile, &quot;%v %v\n&quot;, intermediate[i].Key, output)</code></li>
<li>Map的intermediate输出应存放在当前目录中，便于随后读取作为reduce task的输入</li>
<li><code>mr/coordinator.go</code>应实现一个<code>Done()</code>方法，MapReduce结束后返回true退出程序，可以通过<code>call()</code>方法的返回值来告知worker</li>
</ol>
<h3 id="3-Lab实现"><a href="#3-Lab实现" class="headerlink" title="3. Lab实现"></a>3. Lab实现</h3><h4 id="1-Worker和Master通过RPC实现信息交换"><a href="#1-Worker和Master通过RPC实现信息交换" class="headerlink" title="1. Worker和Master通过RPC实现信息交换"></a>1. Worker和Master通过RPC实现信息交换</h4><p>worker向master请求分配task, master选择合适的task分配给worker; worker完成task后告知master, master将task标记为已完成</p>
<p><strong>1.1 RPC-远程过程调用</strong></p>
<p>RPC - Remote Procedure Call, 是一个计算机通信协议, 该协议允许本地程序调用另一个地址空间(通常为一个开放网络的一台计算机,Lab中为<code>worker.go</code>调用运行在<code>master.go</code>的方法)的子程序, 远端程序执行完毕后返回调用结果到本地程序</p>
<p><img src="/2021/11/13/6-824-lab1/rpc.png" alt="RPC"></p>
<p>Lab中主要通过<code>Call</code>函数实现RPC机制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call(rpcname string, args interface&#123;&#125;, reply interface&#123;&#125;) bool</span><br></pre></td></tr></table></figure>

<p>rpcname: 远程调用的方法(必须是导出的-首字母大写)<br>args: 远程调用方法接受的参数<br>reply: 远程调用方法返回的参数</p>
<p><code>Master.go</code>中首先通过<code>MakeMaster</code>函数实例化了一个Master对象, 并注册了rpc服务, 然后把rpc挂载到http服务上, 在本地网络上侦听来自<code>worker.go</code>的调用信息</p>
<p><code>worker.go</code>中首先与RPC服务器建立连接, 随后调用<code>master.go</code>的方法并等待返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpc.Register(m) // 注册roc服务</span><br><span class="line">rpc.HandleHTTP() // 挂载</span><br><span class="line">l, e := net.Listen(&quot;unix&quot;, sockname)</span><br><span class="line">go http.Serve(l, nil) // 侦听来自sockname的调用</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c, err := rpc.DialHTTP(&quot;unix&quot;, sockname) // 与rpc服务器建立连接</span><br><span class="line">c.Call(rpcname, args, reply) // 远程调用方法</span><br></pre></td></tr></table></figure>

<p><strong>1.2 Worker-&gt;Master</strong></p>
<p>worker-&gt;master的通信主要包括两部分: 请求任务和告知任务完成</p>
<p>分别由<code>CallTask()</code>和<code>CallTaskDone()</code>方法实现, 通过RPC服务对应调用<code>master.go</code>中的<code>AskTask()</code>和<code>AskDone()</code>方法</p>
<p>这里的TaskInfo是一个结构体对象, 描述了master分配task的具体信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">type TaskInfo struct &#123;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	    task state(declared in const above):</span><br><span class="line">	        0 - map</span><br><span class="line">	        1 - reduce</span><br><span class="line">	        2 - wait</span><br><span class="line">	        3 - end</span><br><span class="line">	*/</span><br><span class="line">	State int</span><br><span class="line"></span><br><span class="line">	FileName  string  // task file name</span><br><span class="line">	FileIndex int     // map task index(0 - NFiles-1)</span><br><span class="line">	PartIndex int     // reduce task index(0 - NReduce-1)</span><br><span class="line"></span><br><span class="line">	NReduce int       // reduce task number</span><br><span class="line">	NFiles  int       // map task number</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过RPC远程调用<code>AskTask()</code>函数, reply接受<code>AskTask()</code>生成的TaskInfo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func CallTask() *TaskInfo &#123;</span><br><span class="line"></span><br><span class="line">	// declare an argument structure</span><br><span class="line">	args := TaskArgs&#123;&#125;</span><br><span class="line"></span><br><span class="line">	// declare an reply structure</span><br><span class="line">	reply := TaskInfo&#123;&#125;</span><br><span class="line"></span><br><span class="line">	// send the RPC request, wait for the reply.</span><br><span class="line">	call(&quot;Master.AskTask&quot;, &amp;args, &amp;reply)</span><br><span class="line"></span><br><span class="line">	return &amp;reply</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>worker应该不断尝试向master请求新的任务信息, 并对传回的TaskInfo进行处理, 直到收到master传回的TaskEnd信息 (表示所有task均已完成)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line"></span><br><span class="line">    task := CallTask()</span><br><span class="line">    switch task.State &#123;</span><br><span class="line"></span><br><span class="line">    case TaskMap:</span><br><span class="line">        workerMap(mapf, task)</span><br><span class="line"></span><br><span class="line">    case TaskReduce:</span><br><span class="line">        workerReduce(reducef, task)</span><br><span class="line"></span><br><span class="line">    case TaskWait:</span><br><span class="line">        time.Sleep(time.Duration(time.Second * 5))</span><br><span class="line"></span><br><span class="line">    case TaskEnd:</span><br><span class="line">        fmt.Printf(&quot;all tasks complete.....\n&quot;)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">        panic(&quot;Worker error...&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>worker每完成一个任务, 都应该向master告知任务已完成, master进行对应处理, 同样通过RPC远程调用<code>AskDone()</code>函数, 参数args为对应任务的TaskInfo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func CallTaskDone(taskinfo *TaskInfo) &#123;</span><br><span class="line"></span><br><span class="line">	reply := ExampleReply&#123;&#125;</span><br><span class="line"></span><br><span class="line">	call(&quot;Master.AskDone&quot;, taskinfo, &amp;reply)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.3 Master-&gt;Worker</strong></p>
<p>map和reduce是两种不同的task, 因此需要定义一个任务类接口, 并由两个不同的类实现; 此外, 还需定义一个任务队列类, 以实现任务的入列出列等操作</p>
<p>任务类接口:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type TaskInterface interface &#123;</span><br><span class="line">    GenerateTaskInfo() TaskInfo</span><br><span class="line">    OutOfTime() bool</span><br><span class="line">    GetFileIndex() int</span><br><span class="line">    GetPartIndex() int</span><br><span class="line">    SetNow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口实现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type TaskStat struct &#123;</span><br><span class="line">    beginTime time.Time</span><br><span class="line">    fileName  string</span><br><span class="line">    fileIndex int</span><br><span class="line">    partIndex int</span><br><span class="line">    nReduce   int</span><br><span class="line">    nFiles    int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type MapTaskStat struct &#123;</span><br><span class="line">    TaskStat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ReduceTaskStat struct &#123;</span><br><span class="line">    TaskStat</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>MapTaskStat类和ReduceTaskStat类中包含了TaskStat类, 可以视为继承了TaskStat类, 享有内部的方法和变量</p>
<p>Go语言中的多态可以通过接口实现, MapTaskStat类和ReduceTaskStat类都实现了TaskInterface接口(实现了隐式的向上转型), 从而可以调用相同接口方法的不同实现</p>
<p>任务队列:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type TaskQueue struct &#123;</span><br><span class="line">    taskArray []TaskInterface</span><br><span class="line">    mutex     sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type Master struct &#123;</span><br><span class="line"></span><br><span class="line">    filename []string</span><br><span class="line"></span><br><span class="line">    // map task queue</span><br><span class="line">    mapTaskWaiting TaskQueue</span><br><span class="line">    mapTaskRunning TaskQueue</span><br><span class="line"></span><br><span class="line">    // reduce task queue</span><br><span class="line">    reduceTaskWaiting TaskQueue</span><br><span class="line">    reduceTaskRunning TaskQueue</span><br><span class="line"></span><br><span class="line">    // state</span><br><span class="line">    isDone  bool</span><br><span class="line">    nReduce int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务队列类中包含一个TaskInterface数组和一个mutex互斥锁, 实现了一系列队列操作(Pop, Push, Remove, Size), mutex互斥锁确保同一时间只有一个线程在操作任务队列</p>
<p>(任务队列通过链表实现, mutex互斥锁通过chan实现会更好)</p>
<p>队列操作实现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// mutex lock and unlock</span><br><span class="line"></span><br><span class="line">func (t *TaskQueue) lock() &#123;</span><br><span class="line">    t.mutex.Lock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t *TaskQueue) unlock() &#123;</span><br><span class="line">    t.mutex.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务队列入队, 出队 (先入先出)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func (t *TaskQueue) Pop() TaskInterface &#123;</span><br><span class="line">    t.lock()</span><br><span class="line">    arraylength := len(t.taskArray)</span><br><span class="line">    if arraylength == 0 &#123;</span><br><span class="line">        t.unlock()</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    ret := t.taskArray[0]</span><br><span class="line">    t.taskArray = t.taskArray[1:arraylength]</span><br><span class="line">    t.unlock()</span><br><span class="line">    return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t *TaskQueue) Push(task TaskInterface) &#123;</span><br><span class="line">    t.lock()</span><br><span class="line">    if task == nil &#123;</span><br><span class="line">        t.unlock()</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    t.taskArray = append(t.taskArray, task)</span><br><span class="line">    t.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从任务队列中移除任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func (t *TaskQueue) RemoveTask(fileIndex int, partIndex int) &#123;</span><br><span class="line">    t.lock()</span><br><span class="line">    arraylength := len(t.taskArray)</span><br><span class="line">    for index := 0; index &lt; arraylength; &#123;</span><br><span class="line">        // current task</span><br><span class="line">        task := t.taskArray[index]</span><br><span class="line">        if fileIndex == task.GetFileIndex() &amp;&amp; partIndex == task.GetPartIndex() &#123;</span><br><span class="line">            // if the task is the last one in queue</span><br><span class="line">            // avoid array out of bounds</span><br><span class="line">            if index == arraylength-1 &#123;</span><br><span class="line">                t.taskArray = t.taskArray[:arraylength-1]</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                t.taskArray = append(t.taskArray[:index], t.taskArray[index+1:]...)</span><br><span class="line">            &#125;</span><br><span class="line">            break</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            index++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>对应的master-&gt;worker的通信也包含两部分: 分配任务和处理已完成任务</p>
<p>分别由<code>AskTask()</code>和<code>AskDone()</code>方法实现</p>
<p><code>AskTask()</code>方法根据当前任务完成情况处理worker的请求</p>
<ol>
<li>当前所有task均已完成</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// check for isDone</span><br><span class="line">if m.isDone &#123;</span><br><span class="line">    reply.State = TaskEnd</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>当前还有map task未完成</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// check for map tasks</span><br><span class="line">mapTask := m.mapTaskWaiting.Pop()</span><br><span class="line">if mapTask != nil &#123;</span><br><span class="line">    // record maptask begin time</span><br><span class="line">    mapTask.SetNow()</span><br><span class="line">    // append it to mapTaskRunningQueue</span><br><span class="line">    m.mapTaskRunning.Push(mapTask)</span><br><span class="line">    // generate maptask info</span><br><span class="line">    *reply = mapTask.GenerateTaskInfo()</span><br><span class="line">    fmt.Printf(&quot;Distributing map task on %vth file %v\n&quot;, reply.FileIndex, reply.FileName)</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>当前还有reduce task未完成</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// check for reduce tasks</span><br><span class="line">reduceTask := m.reduceTaskWaiting.Pop()</span><br><span class="line">if reduceTask != nil &#123;</span><br><span class="line">    // record reducetask begin time</span><br><span class="line">    reduceTask.SetNow()</span><br><span class="line">    // append it to reduceTaskRunningQueue</span><br><span class="line">    m.reduceTaskRunning.Push(reduceTask)</span><br><span class="line">    // generate reducetask info</span><br><span class="line">    *reply = reduceTask.GenerateTaskInfo()</span><br><span class="line">    fmt.Printf(&quot;Distributing reduce task on part %v %vth file %v\n&quot;, reply.PartIndex, reply.FileIndex, reply.FileName)</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>当前所有task均在进行中</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if m.mapTaskRunning.Size() &gt; 0 || m.reduceTaskRunning.Size() &gt; 0 &#123;</span><br><span class="line">    // wait for new tasks</span><br><span class="line">    reply.State = TaskWait</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AskDone()</code>方法根据当前完成task的类型 (map/reduce)进行不同的处理</p>
<p>完成map task, master将该任务从mapTaskRunning队列中移除, 如果此时没有map task正在执行或等待执行, 则开始执行reduce task</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">case TaskMap:</span><br><span class="line">    fmt.Printf(&quot;Map task on %v file %v complete\n&quot;, args.FileIndex, args.FileName)</span><br><span class="line">    m.mapTaskRunning.RemoveTask(args.FileIndex, args.PartIndex)</span><br><span class="line">    if m.mapTaskRunning.Size() == 0 &amp;&amp; m.mapTaskWaiting.Size() == 0 &#123;</span><br><span class="line">        // all map tasks done</span><br><span class="line">        // can distribute reduce tasks</span><br><span class="line">        m.DistributeReduce()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>完成reduce task, master将该任务从reduceTaskRunning队列中移除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case TaskReduce:</span><br><span class="line">    fmt.Printf(&quot;Reduce task on %v part complete\n&quot;, args.PartIndex)</span><br><span class="line">    m.reduceTaskRunning.RemoveTask(args.FileIndex, args.PartIndex)</span><br></pre></td></tr></table></figure>

<h4 id="2-Map和Reduce实现"><a href="#2-Map和Reduce实现" class="headerlink" title="2. Map和Reduce实现"></a>2. Map和Reduce实现</h4><p><strong>2.1 文件输入和输出</strong></p>
<p>从测试脚本文件<code>test-mr.sh</code>中可以发现, 在加载完MapReduce插件后, 分别执行了<code>mrmaster.go</code>和<code>mrworker.go</code>文件, </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(cd .. &amp;&amp; go build $RACE mrmaster.go) || exit 1</span><br><span class="line">(cd .. &amp;&amp; go build $RACE mrworker.go) || exit 1</span><br><span class="line">...</span><br><span class="line">timeout -k 2s 180s ../mrmaster ../pg*txt &amp;</span><br><span class="line">...</span><br><span class="line"># start multiple workers.</span><br><span class="line">timeout -k 2s 180s ../mrworker ../../mrapps/wc.so &amp;</span><br><span class="line">timeout -k 2s 180s ../mrworker ../../mrapps/wc.so &amp;</span><br><span class="line">timeout -k 2s 180s ../mrworker ../../mrapps/wc.so &amp;</span><br></pre></td></tr></table></figure>

<p><code>mrmaster.go</code>中调用了<code>master.go</code>中的<code>MakeMaster()</code>方法, 指定了输入文件 (命令行参数)和NReduce的值</p>
<p>输入文件为当前目录下(src/main/)所有以pg开头, txt结尾的文件, 命令末端的’&amp;’字符表示此进程为后台进程</p>
<p><img src="/2021/11/13/6-824-lab1/txt.png" alt="txt"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := mr.MakeMaster(os.Args[1:], 10)</span><br></pre></td></tr></table></figure>

<p>MakeMaster()方法创建并初始化了一个Master对象和一个map任务队列, 并开启了两个线程, 一个用于计时并处理超时任务, 一个用于侦听来自worker的请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// create map task queue</span><br><span class="line">mapArray := make([]TaskInterface, 0)</span><br><span class="line">    for index, file := range files &#123;</span><br><span class="line">        mapTask := MapTaskStat&#123;</span><br><span class="line">        TaskStat&#123;</span><br><span class="line">            fileName:  file,</span><br><span class="line">            fileIndex: index,</span><br><span class="line">            partIndex: 0,</span><br><span class="line">            nReduce:   nReduce,</span><br><span class="line">            nFiles:    len(file),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    mapArray = append(mapArray, &amp;mapTask)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// create master</span><br><span class="line">m := Master&#123;</span><br><span class="line">    filename: files,</span><br><span class="line">    mapTaskWaiting: TaskQueue&#123;</span><br><span class="line">        taskArray: mapArray,</span><br><span class="line">    &#125;,</span><br><span class="line">    isDone:  false,</span><br><span class="line">    nReduce: nReduce,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行完所有map task后, 调用<code>DistributeReduce()</code>方法创建NReduce个reduceTask对象并编号, 然后加入到reduceTaskWaiting队列中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">reduceTask := ReduceTaskStat&#123;</span><br><span class="line">    TaskStat&#123;</span><br><span class="line">	fileIndex: 0,</span><br><span class="line">	partIndex: 0,</span><br><span class="line">	nReduce:   m.nReduce,</span><br><span class="line">	nFiles:    len(m.filename),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for index := 0; index &lt; m.nReduce; index++ &#123;</span><br><span class="line">    task := reduceTask</span><br><span class="line">    task.partIndex = index</span><br><span class="line">    m.reduceTaskWaiting.Push(&amp;task)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mrworker.go</code>中调用了<code>worker.go</code>中的<code>Worker</code>方法, 通过plugin库加载了动态文件<code>wc.so</code>中的Map和Reduce方法作为<code>Worker</code>方法的参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mapf, reducef := loadPlugin(os.Args[1])</span><br><span class="line">mr.Worker(mapf, reducef)</span><br></pre></td></tr></table></figure>

<p>Master接收NFiles个输入txt文件, 对每个map worker分配一个txt文件, 第fileIndex个文件对应第fileIndex个map task;</p>
<p>map worker从txt文件中提取出键值对, 并将键值对划分为NReduce个(临时)文件, 存储在当前目录下, 命名为mr-fileIndex-partIndex;</p>
<p>第partIndex个reduce task读取所有名为mr-*-partIndex的文件, 将它们合并排序, 生成输出文件mr-out-partIndex (测试脚本中将partIndex个输出文件合并得到mr-wc-all)</p>
<p><strong>2.2 Map实现</strong></p>
<p>主要通过workerMap()方法实现:<br><code>workerMap(mapf func(string, string) []KeyValue, taskinfo *TaskInfo)</code><br>Worker()中接收到标记(state)为TaskMap的TaskInfo后, 将mapf方法和TaskInfo对象作为参数调用workerMap()方法</p>
<p>workerMap()方法首先读取txt文件的所有内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(taskinfo.FileName)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    log.Fatalf(&quot;Can not open file %v\n&quot;, taskinfo.FileName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">content, err := ioutil.ReadAll(file)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    log.Fatalf(&quot;Can not read file %v\n&quot;, taskinfo.FileName)</span><br><span class="line">&#125;</span><br><span class="line">file.Close()</span><br></pre></td></tr></table></figure>

<p>然后调用mapf方法提取得到键值对数组, 并将键值对数组分为NReduce份, 对键值对进行json编码后得到NReduce个(临时)输出文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">kva := mapf(taskinfo.FileName, string(content))</span><br><span class="line">intermediate = append(intermediate, kva...)</span><br><span class="line"></span><br><span class="line">// distribute keys among mr-fileindex-*</span><br><span class="line">for _, kv := range intermediate &#123;</span><br><span class="line"></span><br><span class="line">    // get key/value pair reduce task number</span><br><span class="line">    outindex := ihash(kv.Key) % nReduce</span><br><span class="line">    // file = outfiles[outindex]</span><br><span class="line">    enc := fileEncs[outindex]</span><br><span class="line"></span><br><span class="line">    // convert key/value pair to JSON</span><br><span class="line">    err := enc.Encode(&amp;kv)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Printf(&quot;file %v key %v value %v Error %v\n&quot;, taskinfo.FileName, kv.Key, kv.Value, err)</span><br><span class="line">        panic(&quot;Json encode error&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.3 Reduce实现</strong></p>
</font>
            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="m-pagination col-md-8 col-md-offset-2 col-sm-24" role="pagination">
    
    
    <a class="pull-right" href="/2021/11/13/socket/">
        Socket →
    </a>
    
</nav>

        <div class="col-md-8 col-md-offset-2 col-sm-24"><script type="text/javascript">
  /**
   * 搜狐畅言
   */

  /*
  document.write('<div id="SOHUCS" sid="' + window.location.pathname.slice(1) + '" ></div>');

  window.onload = function () {
    (function () {
      var appid = 'cytXXXX';
      var conf = 'prod_xxxxxxxxxxxxxxxxx';
      var width = window.innerWidth || document.documentElement.clientWidth;
      var loadJs = function (d, a, id) {
        var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement;
        var b = document.createElement("script");
        b.setAttribute("type", "text/javascript");
        b.setAttribute("charset", "UTF-8");
        b.setAttribute("src", d);
        if (id) {
          b.setAttribute("id", id);
        }
        if (typeof a === "function") {
          if (window.attachEvent) {
            b.onreadystatechange = function () {
              var e = b.readyState;
              if (e === "loaded" || e === "complete") {
                b.onreadystatechange = null;
                a()
              }
            }
          } else {
            b.onload = a
          }
        }
        c.appendChild(b)
      };

      loadJs("https://changyan.sohu.com/upload/changyan.js", function () {
        window.changyan.api.config({
          appid: appid,
          conf: conf
        })
      });
    })();
  }
  */

</script>
</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By DaiWei Jia. All Rights Reserved.
                </p>
                <p>Theme By <a target="_blank" rel="noopener" href="//go.kieran.top" style="color: #767D84">Kieran</a></p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a>&nbsp;</li>
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



      
</body>
</html>
